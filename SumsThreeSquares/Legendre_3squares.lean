/-
This file was edited by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0729d2b9-613d-4e3a-acfb-043938c3b419

The following was proved by Aristotle:

- theorem LegendreThreeSquareTheorem (n : ℕ) : IsSumOfThreeSquares n ↔
    ∀ a b : ℕ, n ≠ 4^a * (8 * b + 7)
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 57c8fe1a-487b-4cd0-9137-a1bac377ae2c
-/

/-
Formalization of Unimodular Positive-Definite Ternary Quadratic Forms.

We prove that every positive-definite integral ternary quadratic form with determinant 1 is properly equivalent to the sum of three squares.
This involves proving:
- Blichfeldt's Lemma (`blichfeldt_lemma`)
- Minkowski's Theorem for centrally symmetric convex bodies (`minkowski_theorem`)
- The volume of an ellipsoid (`ellipsoid_volume`)
- Lemmas about primitive vectors and SL(n, Z) (`primitive_to_e1`, `shear_lemma`)
- Existence of unit vectors in dimensions 2 and 3 (`unit2`, `unit3`)
- Classification of unimodular binary forms (`unimodular_binary`)
- The main classification theorem (`unimodular_ternary`)

This completes the formalization of the provided LaTeX document.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 95f482b1-52d3-4bce-9e04-0d06486f5384

Sorry, Aristotle was unable to complete the task in time.

-/

/-
Formalization of Dirichlet's proof of Legendre's three-square theorem.
We define integral ternary quadratic forms, their equivalence, and prove key lemmas including the construction of a specific form and the existence of a suitable determinant.
We state the classification of unimodular forms as a hypothesis and prove Legendre's theorem using it.
-/

import Mathlib


open scoped BigOperators

open scoped Real

open scoped Nat

open scoped Classical

open scoped Pointwise

set_option maxHeartbeats 0

set_option maxRecDepth 4000

set_option synthInstance.maxHeartbeats 20000

set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false

set_option autoImplicit false

noncomputable section

#check jacobiSym

#check legendreSym

#check Matrix.SpecialLinearGroup

#check Nat.setOf_prime_and_eq_mod_infinite

/-
A positive integer n is a sum of three squares if n=x^2+y^2+z^2 for some x,y,z in Z.
-/
def IsSumOfThreeSquares (n : ℕ) : Prop := ∃ x y z : ℤ, (n : ℤ) = x^2 + y^2 + z^2

/-
An integral ternary quadratic form is a polynomial F(X,Y,Z)=a11X^2+a22Y^2+a33Z^2+2a12XY+2a13XZ+2a23YZ with aij in Z.
-/
structure IntegralTernaryQuadraticForm where
  a11 : ℤ
  a22 : ℤ
  a33 : ℤ
  a12 : ℤ
  a13 : ℤ
  a23 : ℤ

/-
The associated symmetric matrix of an integral ternary quadratic form.
-/
def IntegralTernaryQuadraticForm.toMatrix (F : IntegralTernaryQuadraticForm) : Matrix (Fin 3) (Fin 3) ℤ :=
  ![![F.a11, F.a12, F.a13],
    ![F.a12, F.a22, F.a23],
    ![F.a13, F.a23, F.a33]]

/-
Evaluation of the quadratic form F at a vector x.
-/
def IntegralTernaryQuadraticForm.eval (F : IntegralTernaryQuadraticForm) (x : Fin 3 → ℤ) : ℤ :=
  (Matrix.vecMul x F.toMatrix) ⬝ᵥ x

/-
The determinant of F is det(MF).
-/
def IntegralTernaryQuadraticForm.det (F : IntegralTernaryQuadraticForm) : ℤ :=
  F.toMatrix.det

/-
Two integral ternary quadratic forms F and G are properly equivalent if there exists A in SL3(Z) such that MG = A^T MF A.
-/
def IntegralTernaryQuadraticForm.ProperlyEquivalent (F G : IntegralTernaryQuadraticForm) : Prop :=
  ∃ A : Matrix.SpecialLinearGroup (Fin 3) ℤ, G.toMatrix = A.1.transpose * F.toMatrix * A.1

/-
The set of integers represented by the quadratic form F.
-/
def IntegralTernaryQuadraticForm.RepresentedSet (F : IntegralTernaryQuadraticForm) : Set ℤ :=
  Set.range (fun x => F.eval x)

/-
If F and G are properly equivalent, then F and G represent the same set of integers.
-/
lemma IntegralTernaryQuadraticForm.represented_integers_invariant (F G : IntegralTernaryQuadraticForm)
    (h : F.ProperlyEquivalent G) : F.RepresentedSet = G.RepresentedSet := by
  ext n;
  obtain ⟨ A, hA ⟩ := h;
  constructor <;> rintro ⟨ x, hx ⟩;
  · use A.1⁻¹.mulVec x;
    unfold IntegralTernaryQuadraticForm.eval at *; aesop;
    simp +decide [ Matrix.vecMul_mulVec, Matrix.dotProduct_mulVec, Matrix.vecMul_transpose, Matrix.det_fin_three ];
    simp +decide [ Matrix.mul_assoc, Matrix.transpose_nonsing_inv, A.2 ];
  · use A.val.mulVec x;
    unfold IntegralTernaryQuadraticForm.eval at *; aesop;
    simp +decide [ Matrix.vecMul_mulVec, Matrix.dotProduct_mulVec, Matrix.vecMul_transpose ]

/-
Checking for Matrix.PosDef and Quadratic Reciprocity theorems.
-/
#check Matrix.PosDef

#check legendreSym.quadratic_reciprocity

#check legendreSym.at_neg_one

#check legendreSym.at_two

/-
Let p be an odd prime and let u be an odd integer. If (u/p)=1, then u is a square modulo 2p.
-/
lemma odd_lift (p : ℕ) [Fact p.Prime] (hp : p ≠ 2) (u : ℤ) (hu_odd : Odd u)
    (h_legendre : legendreSym p u = 1) : IsSquare (u : ZMod (2 * p)) := by
  -- Since p is an odd prime, we know that u is a square modulo p.
  have h_mod_p : ∃ x : ℤ, (x^2 : ℤ) ≡ u [ZMOD p] := by
    rw [ legendreSym.eq_one_iff ] at h_legendre;
    · obtain ⟨ x, hx ⟩ := h_legendre; use x.val; simpa [ sq, ← ZMod.intCast_eq_intCast_iff ] using hx.symm;
    · intro H; rw [ legendreSym ] at h_legendre; simp_all +decide [ legendreSym ] ;
  -- If x is even, replace x by x+p, which is odd and still satisfies (x+p)^2 = x^2 = u (mod p).
  obtain ⟨x, hx⟩ : ∃ x : ℤ, (x^2 : ℤ) ≡ u [ZMOD p] ∧ (Odd x) := by
    obtain ⟨ x, hx ⟩ := h_mod_p; use if Even x then x + p else x; split_ifs <;> simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
    exact ‹Even x›.add_odd ( mod_cast Nat.Prime.odd_of_ne_two Fact.out hp );
  -- Since $x$ is odd, we have $x^2 ≡ 1 \pmod{2}$.
  have hx_mod_2 : (x^2 : ℤ) ≡ 1 [ZMOD 2] := by
    simp_all +decide [ Int.modEq_iff_dvd, ← even_iff_two_dvd, parity_simps ];
  -- Therefore, $x^2 ≡ u \pmod{2p}$.
  have hx_mod_2p : (x^2 : ℤ) ≡ u [ZMOD (2 * p)] := by
    rw [ ← Int.modEq_and_modEq_iff_modEq_mul ] ; aesop;
    · exact hx_mod_2.trans ( by obtain ⟨ k, rfl ⟩ := hu_odd; norm_num [ Int.ModEq, Int.add_emod, Int.mul_emod ] );
    · exact Nat.prime_two.coprime_iff_not_dvd.mpr fun h => hp <| by have := Nat.prime_dvd_prime_iff_eq Nat.prime_two ( Fact.out : Nat.Prime p ) ; tauto;
  use x;
  erw [ ← sq, ← ZMod.intCast_eq_intCast_iff ] at * ; aesop

/-
Definition of positive definite integral ternary quadratic form and the sum of three squares form.
-/
def IntegralTernaryQuadraticForm.PositiveDefinite (F : IntegralTernaryQuadraticForm) : Prop :=
  (F.toMatrix.map (Int.castRingHom ℝ)).PosDef

def IntegralTernaryQuadraticForm.sum_squares : IntegralTernaryQuadraticForm :=
  { a11 := 1, a22 := 1, a33 := 1, a12 := 0, a13 := 0, a23 := 0 }

/-
Construction of the quadratic form F for Lemma 1.8.
-/
def constructedForm (n : ℕ) (D : ℕ) (t : ℤ) : IntegralTernaryQuadraticForm :=
  let a22 := (D : ℤ) * n - 1
  let a11 := ((D : ℤ) + t^2) / a22
  { a11 := a11, a22 := a22, a33 := n, a12 := t, a13 := 1, a23 := 0 }

/-
Lemma 1.8: Construction of F. If t^2 = -D mod (Dn-1), then the constructed form F is positive-definite, has determinant 1, and represents n.
-/
lemma constructF (n : ℕ) (hn : n > 0) (D : ℕ) (hD : D > 0) (hDn : D * n > 1) (t : ℤ)
    (h_cong : t^2 ≡ -D [ZMOD ((D : ℤ) * n - 1)]) :
    let F := constructedForm n D t
    F.PositiveDefinite ∧ F.det = 1 ∧ F.eval ![0, 0, 1] = n := by
  -- Let's unfold the definition of `constructedForm`.
  unfold constructedForm;
  constructor;
  · constructor;
    · ext i j ; fin_cases i <;> fin_cases j <;> rfl;
    · intro x hx_ne_zero
      have h_pos_def : (x 0)^2 * ((D + t^2) / (D * n - 1) : ℝ) + (x 1)^2 * ((D * n - 1) : ℝ) + (x 2)^2 * (n : ℝ) + 2 * x 0 * x 1 * t + 2 * x 0 * x 2 + 2 * x 1 * x 2 * 0 > 0 := by
        by_cases h_case : x 0 = 0;
        · by_cases h_case2 : x 1 = 0 <;> by_cases h_case3 : x 2 = 0 <;> simp_all +decide [ funext_iff, Fin.forall_fin_succ ];
          · positivity;
          · exact mul_pos ( sq_pos_of_ne_zero h_case2 ) ( sub_pos_of_lt ( by norm_cast ) );
          · exact add_pos_of_nonneg_of_pos ( mul_nonneg ( sq_nonneg _ ) ( sub_nonneg_of_le ( by norm_cast; linarith ) ) ) ( mul_pos ( sq_pos_of_ne_zero h_case3 ) ( by positivity ) );
        · -- Since $x_0 \neq 0$, we can complete the square for the quadratic form.
          have h_complete_square : (x 0)^2 * ((D + t^2) / (D * n - 1) : ℝ) + (x 1)^2 * ((D * n - 1) : ℝ) + (x 2)^2 * (n : ℝ) + 2 * x 0 * x 1 * t + 2 * x 0 * x 2 = ((x 0 * t + x 1 * (D * n - 1))^2 / (D * n - 1) : ℝ) + ((x 0)^2 * D / (D * n - 1) : ℝ) + (x 2)^2 * (n : ℝ) + 2 * x 0 * x 2 := by
            field_simp;
            ring;
            nlinarith [ inv_mul_cancel_left₀ ( show ( -1 + D * n : ℝ ) ≠ 0 by nlinarith [ ( by norm_cast : ( 1 : ℝ ) < D * n ) ] ) ( x 0 * t * x 1 * 2 ) ];
          -- Since $x_0 \neq 0$, we can complete the square for the quadratic form and show it is positive.
          have h_complete_square_pos : ((x 0 * t + x 1 * (D * n - 1))^2 / (D * n - 1) : ℝ) + ((x 0)^2 * D / (D * n - 1) : ℝ) + (x 2)^2 * (n : ℝ) + 2 * x 0 * x 2 > 0 := by
            have h_pos : (x 0)^2 * D / (D * n - 1) > 0 := by
              exact div_pos ( mul_pos ( sq_pos_of_ne_zero h_case ) ( Nat.cast_pos.mpr hD ) ) ( sub_pos.mpr ( by norm_cast ) )
            nlinarith [ sq_nonneg ( x 2 * n + x 0 ), show ( n : ℝ ) ≥ 1 by norm_cast, show ( D : ℝ ) ≥ 1 by norm_cast, show ( D * n : ℝ ) ≥ 2 by norm_cast, div_mul_cancel₀ ( x 0 ^ 2 * D ) ( show ( D * n - 1 : ℝ ) ≠ 0 by exact sub_ne_zero_of_ne <| by norm_cast; nlinarith ), div_nonneg ( sq_nonneg ( x 0 * t + x 1 * ( D * n - 1 ) ) ) ( show ( D * n - 1 : ℝ ) ≥ 0 by exact sub_nonneg_of_le <| by norm_cast; nlinarith ) ];
          linarith;
      simp_all +decide [ Matrix.mulVec, dotProduct, Fin.sum_univ_three ];
      convert h_pos_def using 1 ; norm_num [ Matrix.vecHead, Matrix.vecTail, IntegralTernaryQuadraticForm.toMatrix ] ; ring;
      simp +zetaDelta at *;
      rw [ Int.cast_div ] <;> norm_num;
      · ring;
      · convert h_cong.symm.dvd using 1 ; ring;
      · nlinarith [ ( by norm_cast : ( 1 : ℝ ) < D * n ) ];
  · unfold IntegralTernaryQuadraticForm.det IntegralTernaryQuadraticForm.eval; norm_num [ Matrix.vecHead, Matrix.vecTail, Matrix.det_fin_three ] ;
    unfold IntegralTernaryQuadraticForm.toMatrix; norm_num [ Matrix.vecMul ] ; aesop;
    rw [ Int.ediv_mul_cancel ];
    · ring;
    · convert h_cong.symm.dvd using 1 ; ring

/-
Checking for Int.ModEq and Dirichlet's theorem variant.
-/
#check Int.ModEq

#check Nat.forall_exists_prime_gt_and_eq_mod

/-
Case 1 of Lemma 1.9: n = 2 mod 4.
-/
lemma existD_case1 (n : ℕ) (hn : n > 0) (h : n % 4 = 2) :
    ∃ D : ℕ, D > 0 ∧ D * n > 1 ∧ ∃ t : ℤ, t^2 ≡ -D [ZMOD ((D : ℤ) * n - 1)] := by
  -- Since n = 2 mod 4, gcd(2n-1, 4n) = 1. By Dirichlet's theorem, there exists a prime p > n such that p = 2n-1 mod 4n.
  obtain ⟨p, hp₁, hp₂⟩ : ∃ p : ℕ, Nat.Prime p ∧ p > n ∧ p % (4 * n) = 2 * n - 1 := by
    have h_dirichlet : ∃ p : ℕ, Nat.Prime p ∧ p ≡ 2 * n - 1 [MOD 4 * n] ∧ p > n := by
      have h_dirichlet : Set.Infinite {p : ℕ | Nat.Prime p ∧ p ≡ 2 * n - 1 [MOD 4 * n]} := by
        have h_dirichlet : ∀ {a m : ℕ}, 0 < a → 0 < m → Nat.gcd a m = 1 → Set.Infinite {p : ℕ | Nat.Prime p ∧ p ≡ a [MOD m]} := by
          intro a m ha hm hgcd; have := @Nat.forall_exists_prime_gt_and_eq_mod ; aesop;
          rw [ Set.infinite_iff_exists_gt ] ; intro n; specialize @this m ; aesop;
          specialize @this ( by exact NeZero.of_pos hm ) ( a : ZMod m ) ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
          exact Exists.imp ( by aesop ) ( this ( by rw [ isUnit_iff_exists_inv ] ; exact ⟨ a ^ ( Nat.totient m - 1 ), by rw [ ← pow_succ', Nat.sub_add_cancel ( Nat.succ_le_of_lt ( Nat.totient_pos.mpr hm ) ) ] ; exact by have := Nat.ModEq.pow_totient hgcd; simpa [ ← ZMod.natCast_eq_natCast_iff ] using this ⟩ ) n );
        convert h_dirichlet ( show 0 < 2 * n - 1 from Nat.sub_pos_of_lt ( by linarith ) ) ( show 0 < 4 * n from by positivity ) _;
        rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.mul_succ ];
        norm_num [ ( by ring : 4 * n + 8 = 2 * n + 3 + ( 2 * n + 5 ) ), ( by ring : 2 * n + 5 = 2 * n + 3 + 2 ) ];
      exact Exists.elim ( h_dirichlet.exists_gt n ) fun p hp => ⟨ p, hp.1.1, hp.1.2, hp.2 ⟩;
    exact ⟨ h_dirichlet.choose, h_dirichlet.choose_spec.1, h_dirichlet.choose_spec.2.2, h_dirichlet.choose_spec.2.1.symm ▸ Nat.mod_eq_of_lt ( by omega ) ⟩;
  -- Let D = 4k+2. Then p = Dn - 1.
  obtain ⟨k, hk⟩ : ∃ k : ℕ, p = (4 * k + 2) * n - 1 := by
    use (p / (4 * n));
    exact eq_tsub_of_add_eq ( by linarith [ Nat.mod_add_div p ( 4 * n ), Nat.sub_add_cancel ( by linarith : 1 ≤ 2 * n ) ] );
  -- We need to show (-D/p) = 1.
  have h_legendre : jacobiSym (-(4 * k + 2) : ℤ) p = 1 := by
    -- Since $p = 3 \mod 8$, we have $\left(\frac{-1}{p}\right) = -1$ and $\left(\frac{2}{p}\right) = -1$.
    have h_legendre_neg1 : jacobiSym (-1) p = -1 := by
      rw [ jacobiSym.mod_right ] ; aesop;
      · norm_num [ show ( 4 * k + 2 ) * n - 1 = 4 * ( k * n ) + 2 * n - 1 by ring, Nat.add_mod, Nat.mul_mod, h ];
        rw [ show ( 4 * ( k * n ) + 2 * n - 1 ) % 4 = 3 by omega ] ; norm_num;
      · exact hp₁.odd_of_ne_two <| by rintro rfl; omega;
    have h_legendre_2 : jacobiSym 2 p = -1 := by
      rw [ jacobiSym.mod_right ] ; aesop;
      · rw [ ← Nat.mod_add_div n 4, h ] ; ring_nf ;
        norm_num [ add_comm 4, Nat.add_mod, Nat.mul_mod, Nat.mul_div_assoc ];
        norm_num [ show k * 8 + 4 + k * ( n / 4 ) * 16 + n / 4 * 8 - 1 = 8 * ( k + k * ( n / 4 ) * 2 + n / 4 ) + 3 by rw [ Nat.sub_eq_of_eq_add ] ; ring ];
      · exact hp₁.odd_of_ne_two <| by rintro rfl; omega;
    -- Since $D = 2D_1$ with $D_1$ odd, we have $\left(\frac{D}{p}\right) = \left(\frac{2}{p}\right)\left(\frac{D_1}{p}\right)$.
    have h_legendre_D : jacobiSym (4 * k + 2) p = jacobiSym 2 p * jacobiSym (2 * k + 1) p := by
      rw [ ← jacobiSym.mul_left ] ; ring;
    -- Since $D_1$ is odd, we have $\left(\frac{D_1}{p}\right) = \left(\frac{p}{D_1}\right)(-1)^{\frac{p-1}{2} \cdot \frac{D_1-1}{2}}$.
    have h_legendre_D1 : jacobiSym (2 * k + 1) p = jacobiSym p (2 * k + 1) * (-1) ^ ((p - 1) / 2 * (2 * k + 1 - 1) / 2) := by
      rw [ jacobiSym.quadratic_reciprocity ];
      · cases Nat.even_or_odd' p ; aesop;
        · simp_all +decide [ Nat.prime_mul_iff ];
          interval_cases n ; trivial;
        · norm_num [ Nat.add_div, Nat.mul_div_assoc ];
          by_cases h : Even ( w * k ) <;> simp_all +decide [ Nat.even_mul ];
      · exact hp₁.odd_of_ne_two <| by rintro rfl; omega;
      · norm_num;
    -- Since $p = 3 \mod 8$, we have $\left(\frac{p}{D_1}\right) = \left(\frac{-1}{D_1}\right)$.
    have h_legendre_p_D1 : jacobiSym p (2 * k + 1) = jacobiSym (-1) (2 * k + 1) := by
      have h_legendre_p_D1 : p ≡ -1 [ZMOD (2 * k + 1)] := by
        exact Int.modEq_iff_dvd.mpr ⟨ -2 * n, by linarith [ Nat.sub_add_cancel ( show 1 ≤ ( 4 * k + 2 ) * n from Nat.mul_pos ( Nat.succ_pos _ ) hn ) ] ⟩;
      exact?;
    -- Since $D_1$ is odd, we have $\left(\frac{-1}{D_1}\right) = (-1)^{\frac{D_1-1}{2}}$.
    have h_legendre_neg1_D1 : jacobiSym (-1) (2 * k + 1) = (-1) ^ ((2 * k + 1 - 1) / 2) := by
      rw [ jacobiSym.mod_right ] ; norm_num;
      · rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_num;
      · norm_num;
    rw [ neg_eq_neg_one_mul, jacobiSym.mul_left ] ; aesop;
    rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_num;
    · norm_num [ Nat.even_div, Nat.add_mod, Nat.mul_mod ];
    · norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod, Nat.pow_mod ];
      rcases Nat.even_or_odd' ( ( k * n * 8 + n * 6 - 1 - 1 ) / 2 ) with ⟨ c, d | d ⟩ <;> norm_num [ Nat.even_iff, Nat.add_mod, Nat.mul_mod, d ];
      · grind;
      · rw [ Nat.div_eq_iff_eq_mul_left zero_lt_two ] at d ; replace d := congr_arg Even d ; simp_all +decide [ Nat.one_le_iff_ne_zero, parity_simps ];
        exact even_iff_two_dvd.mp ( by rw [ Nat.sub_sub, Nat.even_sub ( by nlinarith only [ hn ] ) ] ; simp +arith +decide [ parity_simps ] );
  -- Since $p = Dn - 1$, $-D$ is a square modulo $p$.
  have h_square : ∃ t : ℤ, t^2 ≡ -(4 * k + 2) [ZMOD p] := by
    haveI := Fact.mk hp₁; simp_all +decide [ jacobiSym, ← ZMod.intCast_eq_intCast_iff ] ;
    norm_num [ Nat.primeFactorsList_prime hp₁ ] at h_legendre;
    haveI := Fact.mk hp₁; simp_all +decide [ legendreSym ] ;
    rw [ quadraticCharFun ] at h_legendre ; aesop;
    obtain ⟨ x, hx ⟩ := h_2;
    use x.val;
    norm_cast at *;
    rw [ Int.subNatNat_of_le ( by nlinarith ) ] ; erw [ ← ZMod.intCast_eq_intCast_iff ] ; aesop;
    ring;
  refine' ⟨ 4 * k + 2, _, _, _ ⟩ <;> aesop;
  nlinarith

/-
Case 2 of Lemma 1.9: n = 1 mod 8.
-/
lemma existD_case2 (n : ℕ) (hn : n > 0) (h : n % 8 = 1) :
    ∃ D : ℕ, D > 0 ∧ D * n > 1 ∧ ∃ t : ℤ, t^2 ≡ -D [ZMOD ((D : ℤ) * n - 1)] := by
  -- Choose $D = 8k + 6$ where $k$ is a positive integer.
  obtain ⟨k, hk⟩ : ∃ k : ℕ, 0 < k ∧ ∃ p : ℕ, Nat.Prime p ∧ p = (8 * k + 6) * n - 1 := by
    have h_dirichlet : ∃ p : ℕ, Nat.Prime p ∧ p ≡ 6 * n - 1 [MOD 8 * n] ∧ p > 8 * n := by
      have := @Nat.forall_exists_prime_gt_and_eq_mod ( 8 * n );
      have h_coprime : Nat.gcd (6 * n - 1) (8 * n) = 1 := by
        rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.mul_succ ];
        norm_num [ ( by ring : 8 * n + 16 = 6 * n + 11 + ( 2 * n + 5 ) ), ( by ring : 6 * n + 11 = 2 * n + 5 + ( 4 * n + 6 ) ), ( by ring : 4 * n + 6 = 2 * n + 5 + ( 2 * n + 1 ) ), ( by ring : 2 * n + 5 = 2 * n + 1 + 4 ) ];
        rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_num;
      have := @this ( NeZero.of_pos ( by positivity ) ) ( ↑ ( 6 * n - 1 ) : ZMod ( 8 * n ) ) ?_ ( 8 * n ) <;> aesop;
      · use w;
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      · -- Since $6n - 1$ is coprime to $8n$, it is invertible modulo $8n$.
        have h_inv : ∃ x : ℤ, (6 * n - 1) * x ≡ 1 [ZMOD (8 * n)] := by
          have := Nat.gcd_eq_gcd_ab ( 6 * n - 1 ) ( 8 * n );
          exact ⟨ Nat.gcdA ( 6 * n - 1 ) ( 8 * n ), Int.modEq_iff_dvd.mpr ⟨ Nat.gcdB ( 6 * n - 1 ) ( 8 * n ), by cases n <;> norm_num [ Nat.succ_mul ] at * ; linarith ⟩ ⟩;
        obtain ⟨ x, hx ⟩ := h_inv; exact isUnit_iff_exists_inv.mpr ⟨ x, by erw [ ← ZMod.intCast_eq_intCast_iff ] at *; aesop ⟩ ;
    obtain ⟨ p, hp₁, hp₂, hp₃ ⟩ := h_dirichlet;
    -- Since $p \equiv 6n - 1 \pmod{8n}$, we can write $p = 8n * m + (6n - 1)$ for some integer $m$.
    obtain ⟨m, hm⟩ : ∃ m : ℕ, p = 8 * n * m + (6 * n - 1) := by
      exact ⟨ p / ( 8 * n ), by linarith [ Nat.mod_add_div p ( 8 * n ), hp₂.symm ▸ Nat.mod_eq_of_lt ( show 6 * n - 1 < 8 * n from by omega ) ] ⟩;
    exact ⟨ m, Nat.pos_of_ne_zero ( by rintro rfl; nlinarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ 6 * n ) ] ), p, hp₁, by rw [ hm ] ; exact eq_tsub_of_add_eq ( by nlinarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ 6 * n ) ] ) ⟩;
  obtain ⟨ p, hp₁, hp₂ ⟩ := hk.2;
  -- Since $p = (8k + 6)n - 1$, we have $(-D/p) = (-2/p)(D1/p)$ where $D = 2D1$ and $D1 = 4k + 3$.
  have h_legendre : jacobiSym (-2) p = -1 ∧ jacobiSym (4 * k + 3) p = -1 := by
    constructor;
    · -- Since $p \equiv 5 \pmod{8}$, we have $p \equiv 1 \pmod{4}$.
      have hp_mod : p % 8 = 5 := by
        rw [ hp₂, ← Nat.mod_add_div ( ( 8 * k + 6 ) * n ) 8 ] ; norm_num [ Nat.add_mod, Nat.mul_mod, h ];
      rw [ jacobiSym.mod_right ] ; norm_num [ hp_mod ];
      bound;
      exact left_1.odd_of_ne_two <| by omega;
    · -- Since $p \equiv 5 \pmod{8}$, we have $(p/D1) = (-1/D1) = -1$.
      have h_legendre_D1 : jacobiSym p (4 * k + 3) = -1 := by
        have h_legendre_D1 : jacobiSym p (4 * k + 3) = jacobiSym (-1) (4 * k + 3) := by
          have h_legendre_D1 : p ≡ -1 [ZMOD (4 * k + 3)] := by
            exact Int.modEq_iff_dvd.mpr ⟨ -2 * n, by linarith [ Nat.sub_add_cancel ( show 1 ≤ ( 8 * k + 6 ) * n from Nat.mul_pos ( Nat.succ_pos _ ) hn ) ] ⟩;
          exact?;
        rw [ h_legendre_D1, jacobiSym.mod_right ] ; norm_num;
        norm_num [ parity_simps ];
      rw [ jacobiSym.quadratic_reciprocity ] at * ; aesop;
      · by_cases h : Even ( ( ( 8 * k + 6 ) * n - 1 ) / 2 * ( ( 4 * k + 3 ) / 2 ) ) <;> simp_all +decide;
        grind +ring;
      · exact hp₁.odd_of_ne_two <| by rintro rfl; rw [ eq_tsub_iff_add_eq_of_le ] at hp₂ <;> nlinarith;
      · norm_num [ parity_simps ];
  -- Therefore, $(-D/p) = (-2/p)(D1/p) = (-1)(-1) = 1$.
  have h_legendre_prod : jacobiSym (-((8 * k + 6) : ℤ)) p = 1 := by
    rw [ show ( - ( 8 * k + 6 ) : ℤ ) = ( -2 : ℤ ) * ( 4 * k + 3 ) by ring, jacobiSym.mul_left ] ; aesop;
  -- Since $(-D/p) = 1$, there exists an integer $t$ such that $t^2 ≡ -D \pmod{p}$.
  obtain ⟨t, ht⟩ : ∃ t : ℤ, t^2 ≡ -(8 * k + 6) [ZMOD p] := by
    haveI := Fact.mk hp₁; norm_num [ ← ZMod.intCast_eq_intCast_iff, jacobiSym ] at *;
    norm_num [ Nat.primeFactorsList_prime hp₁ ] at h_legendre_prod;
    rw [ legendreSym.eq_one_iff ] at h_legendre_prod;
    · obtain ⟨ x, hx ⟩ := h_legendre_prod; use x.val; simpa [ sq, ← ZMod.intCast_eq_intCast_iff ] using hx.symm;
    · intro H; simp_all +decide [ legendreSym ];
  refine' ⟨ 8 * k + 6, _, _, t, _ ⟩ <;> norm_num;
  · nlinarith;
  · grind

/-
Case 3 of Lemma 1.9: n = 3 mod 8.
-/
lemma existD_case3 (n : ℕ) (hn : n > 0) (h : n % 8 = 3) :
    ∃ D : ℕ, D > 0 ∧ D * n > 1 ∧ ∃ t : ℤ, t^2 ≡ -D [ZMOD ((D : ℤ) * n - 1)] := by
  -- Choose p = (5n-1)/2 mod 4n. Note 5n-1 = 15-1 = 14 mod 8, so (5n-1)/2 = 7 mod 4, i.e. 3 mod 4.
  obtain ⟨p, hp1, hp2⟩ : ∃ p, Nat.Prime p ∧ p ≡ 3 [MOD 4] ∧ p ≡ (5 * n - 1) / 2 [MOD 4 * n] := by
    -- By Dirichlet's theorem on arithmetic progressions, there are infinitely many primes in the residue class $r \mod 4n$.
    have h_dirichlet : ∀ r : ℕ, Nat.gcd r (4 * n) = 1 → ∃ p, Nat.Prime p ∧ p ≡ r [MOD 4 * n] := by
      intro r hr_coprime
      have h_dirichlet : ∃ p, Nat.Prime p ∧ p ≡ r [MOD 4 * n] := by
        have h_inf_primes : Set.Infinite {p : ℕ | Nat.Prime p ∧ p ≡ r [MOD 4 * n]} := by
          have := @Nat.forall_exists_prime_gt_and_eq_mod;
          rw [ Set.infinite_iff_exists_gt ] ; aesop;
          specialize @this ( 4 * n ) ?_ r ?_ ( a + 1 );
          · exact ⟨ by positivity ⟩;
          · exact?;
          · obtain ⟨ p, hp₁, hp₂, hp₃ ⟩ := this; exact ⟨ p, ⟨ hp₂, by simpa [ ← ZMod.natCast_eq_natCast_iff ] using hp₃ ⟩, by linarith ⟩ ;
        exact h_inf_primes.nonempty;
      exact h_dirichlet;
    -- Let $r = (5n-1)/2$. We need to show that $\gcd(r, 4n) = 1$.
    have hr_gcd : Nat.gcd ((5 * n - 1) / 2) (4 * n) = 1 := by
      -- Since $n \equiv 3 \pmod{8}$, we can write $n = 8k + 3$ for some integer $k$.
      obtain ⟨k, rfl⟩ : ∃ k, n = 8 * k + 3 := by
        exact ⟨ n / 8, by rw [ ← h, Nat.div_add_mod ] ⟩;
      norm_num [ show 5 * ( 8 * k + 3 ) - 1 = 2 * ( 20 * k + 7 ) by rw [ Nat.sub_eq_of_eq_add ] ; ring ];
      norm_num [ ( by ring : 4 * ( 8 * k + 3 ) = 2 * ( 16 * k + 6 ) ), ( by ring : 20 * k + 7 = ( 16 * k + 6 ) + ( 4 * k + 1 ) ), Nat.gcd_add_self_right ];
      norm_num [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
      norm_num [ ( by ring : 16 * k + 6 = 4 * ( 4 * k + 1 ) + 2 ) ];
      simp +arith +decide [ parity_simps ];
    obtain ⟨ p, hp₁, hp₂ ⟩ := h_dirichlet _ hr_gcd; use p; aesop;
    exact hp₂.of_dvd ( dvd_mul_of_dvd_left ( by decide ) _ ) |> Nat.ModEq.trans <| Nat.ModEq.symm <| Nat.modEq_of_dvd <| by omega;
  -- Let D be such that 2p = Dn - 1.
  obtain ⟨D, hD⟩ : ∃ D : ℕ, 2 * p = D * n - 1 := by
    -- Since $p \equiv (5n-1)/2 \pmod{4n}$, we have $2p \equiv 5n-1 \pmod{4n}$.
    have h_cong : 2 * p ≡ 5 * n - 1 [MOD 4 * n] := by
      convert hp2.2.mul_left 2 using 1;
      grind;
    obtain ⟨ D, hD ⟩ := h_cong.symm.dvd;
    exact ⟨ Int.toNat ( 4 * D + 5 ), eq_tsub_of_add_eq <| by push_cast [ Nat.cast_sub ( show 1 ≤ 5 * n by linarith ) ] at *; nlinarith [ Int.toNat_of_nonneg ( show ( 4 * D + 5 : ℤ ) ≥ 0 by nlinarith [ hp1.two_le ] ) ] ⟩;
  -- Since $p \equiv 3 \pmod{4}$ and $D \equiv 5 \pmod{8}$, we have $\left(\frac{-D}{p}\right) = 1$.
  have h_legendre : jacobiSym (-D) p = 1 := by
    -- Since $p \equiv 3 \pmod{4}$ and $D \equiv 5 \pmod{8}$, we have $\left(\frac{D}{p}\right) = \left(\frac{p}{D}\right)$.
    have h_jacobi_symm : jacobiSym D p = jacobiSym p D := by
      rw [ jacobiSym.quadratic_reciprocity ];
      · -- Since $D \equiv 1 \pmod{4}$, we have $D / 2$ is even.
        have hD_even : Even (D / 2) := by
          rw [ eq_tsub_iff_add_eq_of_le ] at hD;
          · replace hD := congr_arg ( · % 8 ) hD ; norm_num [ Nat.add_mod, Nat.mul_mod, h ] at hD;
            rw [ Nat.ModEq ] at hp2; rw [ ← Nat.mod_mod_of_dvd p ( by decide : 4 ∣ 8 ) ] at hp2; have := Nat.mod_lt p ( by decide : 0 < 8 ) ; interval_cases p % 8 <;> norm_num at * <;> rw [ Nat.even_iff ] <;> omega;
          · exact Nat.pos_of_ne_zero ( by aesop_cat );
        norm_num [ hD_even, parity_simps ];
      · rw [ eq_tsub_iff_add_eq_of_le ] at hD;
        · replace hD := congr_arg Even hD; simp_all +decide [ parity_simps ] ;
        · exact Nat.pos_of_ne_zero ( by aesop_cat );
      · bound;
        exact hp1.odd_of_ne_two <| by rintro rfl; contradiction;
    -- Since $p \equiv 3 \pmod{4}$ and $D \equiv 5 \pmod{8}$, we have $\left(\frac{p}{D}\right) = \left(\frac{2p}{D}\right) \left(\frac{2}{D}\right)^{-1}$.
    have h_jacobi_split : jacobiSym p D = jacobiSym (2 * p) D * jacobiSym 2 D := by
      rw [ ← jacobiSym.mul_left ] ; ring;
      rw [ jacobiSym.mul_left ];
      rw [ show ( 4 : ℤ ) = 2 ^ 2 by norm_num, jacobiSym.pow_left ];
      rw [ jacobiSym.sq_one ] ; aesop;
      rcases Nat.even_or_odd' D with ⟨ k, rfl | rfl ⟩ <;> norm_num at *;
      rw [ eq_tsub_iff_add_eq_of_le ] at hD;
      · have := congr_arg Even hD; norm_num [ hp1.even_iff, hn.ne', parity_simps ] at this;
      · contrapose! hD; aesop;
    -- Since $p \equiv 3 \pmod{4}$ and $D \equiv 5 \pmod{8}$, we have $\left(\frac{2p}{D}\right) = \left(\frac{-1}{D}\right)$.
    have h_jacobi_neg_one : jacobiSym (2 * p) D = jacobiSym (-1) D := by
      have h_jacobi_neg_one : 2 * p ≡ -1 [ZMOD D] := by
        exact Int.modEq_iff_dvd.mpr ⟨ -n, by linarith [ Nat.sub_add_cancel ( show 1 ≤ D * n from Nat.mul_pos ( Nat.pos_of_ne_zero ( by aesop_cat ) ) hn ) ] ⟩;
      exact?;
    -- Since $D \equiv 5 \pmod{8}$, we have $\left(\frac{-1}{D}\right) = 1$.
    have h_jacobi_neg_one_D : jacobiSym (-1) D = 1 := by
      rw [ jacobiSym.mod_right ] ; norm_num;
      · rw [ ← Nat.mod_mod_of_dvd D ( by decide : 4 ∣ 8 ), show D % 8 = 5 from ?_ ] ; norm_num;
        rw [ eq_tsub_iff_add_eq_of_le ] at hD;
        · have := congr_arg ( · % 8 ) hD; norm_num [ Nat.add_mod, Nat.mul_mod, h ] at this; have := Nat.mod_lt D ( by decide : 0 < 8 ) ; interval_cases D % 8 <;> norm_num at *;
          all_goals rw [ Nat.ModEq ] at hp2; omega;
        · contrapose! hD; aesop;
      · rw [ eq_tsub_iff_add_eq_of_le ] at hD;
        · replace hD := congr_arg Even hD; simp_all +decide [ parity_simps ] ;
        · contrapose! hD; aesop;
    -- Since $D \equiv 5 \pmod{8}$, we have $\left(\frac{2}{D}\right) = -1$.
    have h_jacobi_two_D : jacobiSym 2 D = -1 := by
      rw [ jacobiSym.mod_right ] ; norm_num;
      · rw [ eq_tsub_iff_add_eq_of_le ] at hD;
        · have := congr_arg ( · % 8 ) hD; norm_num [ Nat.add_mod, Nat.mul_mod, h ] at this; have := Nat.mod_lt D ( by decide : 0 < 8 ) ; interval_cases D % 8 <;> norm_num at *;
          all_goals rw [ Nat.ModEq ] at hp2; omega;
        · exact Nat.mul_pos ( Nat.pos_of_ne_zero ( by rintro rfl; norm_num at * ; linarith [ hp1.two_le ] ) ) hn;
      · rw [ eq_tsub_iff_add_eq_of_le ] at hD;
        · replace hD := congr_arg Even hD; simp_all +decide [ parity_simps ] ;
        · exact Nat.mul_pos ( Nat.pos_of_ne_zero ( by rintro rfl; norm_num at * ; linarith [ hp1.two_le ] ) ) hn;
    rw [ neg_eq_neg_one_mul, jacobiSym.mul_left ] ; aesop;
    rw [ jacobiSym.at_neg_one ];
    · rw [ ZMod.χ₄_nat_mod_four ] ; rw [ left ] ; rfl;
    · exact hp1.odd_of_ne_two <| by rintro rfl; contradiction;
  -- Since $-D$ is a square modulo $p$, by odd_lift, $-D$ is a square modulo $2p = Dn - 1$.
  obtain ⟨t, ht⟩ : ∃ t : ℤ, t^2 ≡ -D [ZMOD p] := by
    rw [ jacobiSym ] at h_legendre;
    norm_num [ Nat.primeFactorsList_prime hp1 ] at h_legendre;
    haveI := Fact.mk hp1; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, legendreSym ] ;
    rw [ quadraticCharFun ] at h_legendre ; aesop;
    obtain ⟨ x, hx ⟩ := h_2; use x.val; simpa [ sq, ← ZMod.intCast_eq_intCast_iff ] using hx.symm;
  -- Since $-D$ is a square modulo $p$, by odd_lift, $-D$ is a square modulo $2p = Dn - 1$. Hence, there exists $t'$ such that $t'^2 \equiv -D \pmod{2p}$.
  obtain ⟨t', ht'⟩ : ∃ t' : ℤ, t'^2 ≡ -D [ZMOD (2 * p)] := by
    -- Since $p$ is odd, we can apply the Chinese Remainder Theorem to find such a $t'$.
    obtain ⟨t', ht'⟩ : ∃ t' : ℤ, t'^2 ≡ -D [ZMOD p] ∧ t'^2 ≡ -D [ZMOD 2] := by
      use t + p * (if t^2 % 2 = (-D : ℤ) % 2 then 0 else 1);
      split_ifs <;> simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      · norm_num [ Int.ModEq, ‹_› ];
      · norm_num [ Int.ModEq, Int.add_emod, Int.mul_emod, sq ] at *;
        cases Int.emod_two_eq_zero_or_one t <;> cases Int.emod_two_eq_zero_or_one D <;> simp_all +decide only [Nat.ModEq];
        · norm_cast; norm_num [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ), hp2.1 ] ;
        · norm_cast; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
    use t';
    rw [ ← Int.modEq_and_modEq_iff_modEq_mul ] ; tauto;
    exact Nat.prime_two.coprime_iff_not_dvd.mpr fun h => by have := Nat.Prime.eq_two_or_odd hp1; simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ] ;
  refine' ⟨ D, _, _, t', _ ⟩ <;> norm_cast at * ; aesop;
  · contrapose! hD; aesop;
  · exact Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨ by aesop_cat, by aesop_cat ⟩;
  · rw [ Int.subNatNat_of_le ( Nat.one_le_iff_ne_zero.mpr <| by aesop_cat ) ] ; aesop

/-
Case 4 of Lemma 1.9: n = 5 mod 8.
-/
lemma existD_case4 (n : ℕ) (hn : n > 0) (h : n % 8 = 5) :
    ∃ D : ℕ, D > 0 ∧ D * n > 1 ∧ ∃ t : ℤ, t^2 ≡ -D [ZMOD ((D : ℤ) * n - 1)] := by
  -- Let $p$ be a prime such that $p = (3n - 1)/2 \pmod{4n}$ and $p \equiv 3 \pmod{4}$.
  obtain ⟨p, hp_prime, hp_mod, hp_mod_4⟩ : ∃ p : ℕ, Nat.Prime p ∧ p % (4 * n) = (3 * n - 1) / 2 ∧ p % 4 = 3 := by
    -- By Dirichlet's theorem, there exists a prime $p$ such that $p \equiv (3n-1)/2 \pmod{4n}$.
    have h_dirichlet : ∃ p : ℕ, Nat.Prime p ∧ p ≡ (3 * n - 1) / 2 [MOD 4 * n] := by
      have h_coprime : Nat.gcd ((3 * n - 1) / 2) (4 * n) = 1 := by
        rcases Nat.even_or_odd' n with ⟨ c, rfl | rfl ⟩ <;> norm_num at *;
        · omega;
        · norm_num [ show 3 * ( 2 * c + 1 ) - 1 = 2 * ( 3 * c + 1 ) by rw [ Nat.sub_eq_of_eq_add ] ; ring ];
          norm_num [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
          exact ⟨ by rw [ show 4 = 2 ^ 2 by norm_num ] ; exact Nat.Coprime.pow_right _ <| Nat.Coprime.symm <| Nat.prime_two.coprime_iff_not_dvd.2 <| by omega, by rw [ show 3 * c + 1 = 2 * c + 1 + ( c ) by ring ] ; aesop ⟩
      have h_dirichlet : ∃ p : ℕ, Nat.Prime p ∧ p ≡ (3 * n - 1) / 2 [MOD 4 * n] := by
        have h_coprime : Nat.gcd ((3 * n - 1) / 2) (4 * n) = 1 := h_coprime
        have h_dirichlet : Set.Infinite {p : ℕ | Nat.Prime p ∧ p ≡ (3 * n - 1) / 2 [MOD 4 * n]} := by
          have := @Nat.forall_exists_prime_gt_and_eq_mod ( 4 * n );
          rw [ Set.infinite_iff_exists_gt ];
          intro a; specialize @this ( by exact ⟨ by positivity ⟩ ) ( ↑ ( ( 3 * n - 1 ) / 2 ) : ZMod ( 4 * n ) ) ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          have h_unit : IsUnit (↑((3 * n - 1) / 2) : ZMod (4 * n)) := by
            exact?;
          exact Exists.elim ( this h_unit ( a + 1 ) ) fun p hp => ⟨ p, ⟨ hp.2.1, hp.2.2 ⟩, by linarith ⟩
        exact h_dirichlet.nonempty;
      exact h_dirichlet;
    cases' h_dirichlet with p hp; use p; aesop;
    · rw [ right, Nat.mod_eq_of_lt ( Nat.div_lt_of_lt_mul <| by omega ) ];
    · rw [ right.of_dvd <| dvd_mul_right _ _ ] ; omega;
  -- Let $D = \frac{2p + 1}{n}$.
  obtain ⟨D, hD_pos, hD_eq⟩ : ∃ D : ℕ, D > 0 ∧ D * n = 2 * p + 1 := by
    have h_div : n ∣ (2 * p + 1) := by
      rw [ ← Nat.mod_add_div p ( 4 * n ), hp_mod ] ; ring_nf ; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] ; aesop;
      rw [ Nat.div_mul_cancel ( even_iff_two_dvd.mp ( by rw [ Nat.even_sub ( by linarith ) ] ; norm_num [ Nat.even_iff, Nat.add_mod, Nat.mul_mod ] ; omega ) ) ] ; rw [ Nat.add_sub_cancel' ( by linarith ) ] ; norm_num;
    exact ⟨ ( 2 * p + 1 ) / n, Nat.div_pos ( Nat.le_of_dvd ( Nat.succ_pos _ ) h_div ) hn, Nat.div_mul_cancel h_div ⟩;
  -- Since $p$ is prime and $p \equiv 3 \pmod{4}$, we have $(-D/p) = 1$.
  have h_legendre : jacobiSym (-D) p = 1 := by
    -- Since $p$ is prime and $p \equiv 3 \pmod{4}$, we have $(-1/p) = -1$ and $(D/p) = -(p/D)$.
    have h_legendre_neg_one : jacobiSym (-1) p = -1 := by
      rw [ jacobiSym.mod_right ] ; aesop;
      · native_decide +revert;
      · exact hp_prime.odd_of_ne_two <| by rintro rfl; omega;
    have h_legendre_D : jacobiSym D p = -jacobiSym p D := by
      rw [ jacobiSym.quadratic_reciprocity ] ; aesop;
      · rcases Nat.even_or_odd' D with ⟨ k, rfl | rfl ⟩ <;> rcases Nat.even_or_odd' p with ⟨ l, rfl | rfl ⟩ <;> norm_num at *;
        · omega;
        · have := congr_arg ( · % 2 ) hD_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this;
        · omega;
        · rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> rcases Nat.even_or_odd' l with ⟨ l, rfl | rfl ⟩ <;> ring_nf <;> norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
          · have := Nat.mod_lt l zero_lt_four; interval_cases l % 4 <;> contradiction;
          · grind;
          · have := Nat.mod_lt l zero_lt_four; interval_cases l % 4 <;> contradiction;
          · norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ];
      · replace hD_eq := congr_arg Even hD_eq; simp_all +decide [ parity_simps ] ;
      · exact hp_prime.odd_of_ne_two <| by aesop_cat;
    -- Since $p$ is prime and $p \equiv 3 \pmod{4}$, we have $(p/D) = (2p/D)(2/D) = (-1/D)(2/D)$.
    have h_legendre_p_D : jacobiSym p D = jacobiSym (-1) D * jacobiSym 2 D := by
      have h_legendre_p_D : jacobiSym p D = jacobiSym (2 * p) D * jacobiSym 2 D := by
        rw [ ← jacobiSym.mul_left ] ; ring;
        rw [ jacobiSym.mul_left ];
        rw [ show ( 4 : ℤ ) = 2 ^ 2 by norm_num, jacobiSym.pow_left ];
        rw [ jacobiSym.sq_one ] ; aesop;
        exact Nat.prime_two.coprime_iff_not_dvd.mpr fun h => by obtain ⟨ k, hk ⟩ := h; replace hD_eq := congr_arg Even hD_eq; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
      -- Since $2p \equiv -1 \pmod{D}$, we have $\left(\frac{2p}{D}\right) = \left(\frac{-1}{D}\right)$.
      have h_legendre_2p : jacobiSym (2 * p) D = jacobiSym (-1) D := by
        rw [ show ( 2 * p : ℤ ) = -1 + D * n by linarith ] ; norm_num [ jacobiSym.mod_left ] ;
      rw [ h_legendre_p_D, h_legendre_2p ];
    -- Since $D$ is odd and $D \equiv 3 \pmod{8}$, we have $(-1/D) = -1$ and $(2/D) = -1$.
    have h_legendre_neg_one_D : jacobiSym (-1) D = -1 := by
      rw [ jacobiSym.mod_right ] ; aesop;
      · rw [ ← Nat.mod_add_div D 4 ] at *; have := Nat.mod_lt D zero_lt_four; interval_cases D % 4 <;> norm_num at *;
        · have := congr_arg ( · % 2 ) hD_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this;
        · replace hD_eq := congr_arg ( · % 8 ) hD_eq ; norm_num [ Nat.add_mod, Nat.mul_mod, h, hp_mod_4 ] at hD_eq;
          rw [ ← Nat.mod_mod_of_dvd p ( by decide : 4 ∣ 8 ) ] at hp_mod_4; have := Nat.mod_lt p ( by decide : 0 < 8 ) ; interval_cases p % 8 <;> ( have := Nat.mod_lt ( D / 4 ) ( by decide : 0 < 8 ) ; interval_cases D / 4 % 8 <;> contradiction; );
        · have := congr_arg ( · % 2 ) hD_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this;
      · replace hD_eq := congr_arg Even hD_eq; simp_all +decide [ parity_simps ] ;
    have h_legendre_two_D : jacobiSym 2 D = -1 := by
      rw [ jacobiSym.mod_right ] ; aesop;
      · have := congr_arg ( · % 8 ) hD_eq; norm_num [ Nat.add_mod, Nat.mul_mod, h ] at this; have := Nat.mod_lt D ( by decide : 0 < 8 ) ; interval_cases D % 8 <;> norm_num at *;
        all_goals omega;
      · replace hD_eq := congr_arg Even hD_eq; simp_all +decide [ parity_simps ] ;
    rw [ neg_eq_neg_one_mul, jacobiSym.mul_left ] ; aesop;
  -- Since $-D$ is a square modulo $p$, it follows that $-D$ is also a square modulo $2p$.
  have h_square_mod_2p : ∃ t : ℤ, t^2 ≡ -D [ZMOD 2 * p] := by
    -- Since $-D$ is a square modulo $p$, there exists an integer $t$ such that $t^2 \equiv -D \pmod{p}$.
    obtain ⟨t, ht⟩ : ∃ t : ℤ, t^2 ≡ -D [ZMOD p] := by
      rw [ jacobiSym ] at h_legendre;
      norm_num [ Nat.primeFactorsList_prime hp_prime ] at h_legendre;
      haveI := Fact.mk hp_prime; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, legendreSym ] ;
      rw [ quadraticCharFun ] at h_legendre ; aesop;
      obtain ⟨ t, ht ⟩ := h_2; use t.val; simpa [ sq, ← ZMod.intCast_eq_intCast_iff ] using ht.symm;
    -- Since $-D$ is a square modulo $p$, we can find an integer $t$ such that $t^2 \equiv -D \pmod{2p}$.
    obtain ⟨t, ht⟩ : ∃ t : ℤ, t^2 ≡ -D [ZMOD p] ∧ t^2 ≡ -D [ZMOD 2] := by
      use t + p * (if t^2 % 2 = (-D : ℤ) % 2 then 0 else 1);
      split_ifs <;> simp_all +decide [ Int.ModEq, ← even_iff_two_dvd, parity_simps ];
      norm_num [ sq, Int.add_emod, Int.mul_emod ] at * ; aesop;
      norm_num [ Int.add_emod, show ( p : ℤ ) % 2 = 1 by exact_mod_cast Nat.odd_iff.mp ( hp_prime.odd_of_ne_two <| by aesop_cat ) ] at * ; have := Int.emod_nonneg t two_ne_zero ; have := Int.emod_lt_of_pos t two_pos ; interval_cases t % 2 <;> have := Int.emod_nonneg D two_ne_zero <;> have := Int.emod_lt_of_pos D two_pos <;> interval_cases ( D : ℤ ) % 2 <;> trivial;
    use t;
    rw [ ← Int.modEq_and_modEq_iff_modEq_mul ] ; tauto;
    exact Nat.prime_two.coprime_iff_not_dvd.mpr fun h => by have := Nat.Prime.eq_two_or_odd hp_prime; omega;
  use D;
  grind

/-
Lemma 1.9: Existence of D. For n = 1, 2, 3, 5, 6 mod 8, there exists D such that -D is a square mod (Dn-1).
-/
lemma existD (n : ℕ) (hn : n > 0) (h_mod : n % 8 ∈ ({1, 2, 3, 5, 6} : Set ℕ)) :
    ∃ D : ℕ, D > 0 ∧ D * n > 1 ∧ ∃ t : ℤ, t^2 ≡ -D [ZMOD ((D : ℤ) * n - 1)] := by
  rcases h_mod with ( h | h | h | h | h ) <;> simp_all +decide;
  · exact?;
  · exact existD_case1 n hn ( by omega );
  · exact?;
  · exact?;
  · exact existD_case1 _ hn ( by omega )

/-
Proposition 3.1: If n is a sum of three squares, then n is not of the form 4^a(8b+7).
-/
lemma prop_onlyif (n : ℕ) (h : IsSumOfThreeSquares n) :
    ∀ a b : ℕ, n ≠ 4^a * (8 * b + 7) := by
  intro a b H;
  -- We proceed by induction on $a$.
  induction' a with a ih generalizing n b;
  · obtain ⟨ x, y, z, h ⟩ := h ; norm_cast at h ; aesop;
    exact absurd ( congr_arg ( · % 8 ) h ) ( by norm_num [ sq, Int.add_emod, Int.mul_emod ] ; have := Int.emod_nonneg x ( by norm_num : ( 8 : ℤ ) ≠ 0 ) ; have := Int.emod_nonneg y ( by norm_num : ( 8 : ℤ ) ≠ 0 ) ; have := Int.emod_nonneg z ( by norm_num : ( 8 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos x ( by norm_num : ( 0 : ℤ ) < 8 ) ; have := Int.emod_lt_of_pos y ( by norm_num : ( 0 : ℤ ) < 8 ) ; have := Int.emod_lt_of_pos z ( by norm_num : ( 0 : ℤ ) < 8 ) ; interval_cases x % 8 <;> interval_cases y % 8 <;> interval_cases z % 8 <;> trivial );
  · obtain ⟨x, y, z, h_square⟩ : ∃ x y z : ℤ, n = x^2 + y^2 + z^2 := by
      exact h;
    -- Since $x^2 + y^2 + z^2 = 4^{a+1}(8b + 7)$, we have that $x$, $y$, and $z$ are all even.
    have h_even : Even x ∧ Even y ∧ Even z := by
      replace h_square := congr_arg ( · % 4 ) h_square ; rcases Int.even_or_odd' x with ⟨ k, rfl | rfl ⟩ <;> rcases Int.even_or_odd' y with ⟨ l, rfl | rfl ⟩ <;> rcases Int.even_or_odd' z with ⟨ m, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Int.add_emod, Int.mul_emod, H ] at *;
    -- Let $x = 2x_1$, $y = 2y_1$, and $z = 2z_1$ for some integers $x_1$, $y_1$, and $z_1$.
    obtain ⟨x1, rfl⟩ := h_even.left
    obtain ⟨y1, rfl⟩ := h_even.right.left
    obtain ⟨z1, rfl⟩ := h_even.right.right;
    exact ih ( Int.natAbs ( x1 ^ 2 + y1 ^ 2 + z1 ^ 2 ) ) ( by exact ⟨ x1.natAbs, y1.natAbs, z1.natAbs, by simpa [ ← Int.natCast_inj ] using by linarith ⟩ ) b ( by cases abs_cases ( x1 ^ 2 + y1 ^ 2 + z1 ^ 2 ) <;> nlinarith [ pow_succ' 4 a ] )

/-
Theorem 1.6: Every positive-definite integral ternary quadratic form F with determinant 1 is properly equivalent to X^2+Y^2+Z^2.
-/
def UnimodularEquivalenceFact : Prop :=
  ∀ F : IntegralTernaryQuadraticForm, F.PositiveDefinite → F.det = 1 →
    F.ProperlyEquivalent IntegralTernaryQuadraticForm.sum_squares

/-
If m is not divisible by 4 and not 7 mod 8, then m mod 8 is in {1, 2, 3, 5, 6}.
-/
lemma not_mod_four_eq_zero_of_not_mod_eight_eq_seven (m : ℕ) (h4 : m % 4 ≠ 0) (h7 : m % 8 ≠ 7) :
    m % 8 ∈ ({1, 2, 3, 5, 6} : Set ℕ) := by
  rw [ ← Nat.mod_mod_of_dvd m ( by decide : 4 ∣ 8 ) ] at h4; have := Nat.mod_lt m ( by decide : 0 < 8 ) ; interval_cases m % 8 <;> trivial;

/-
Any positive integer n can be written as 4^a * m where m is not divisible by 4.
-/
lemma reduction_lemma (n : ℕ) (hn : n > 0) :
    ∃ a m : ℕ, n = 4^a * m ∧ m % 4 ≠ 0 := by
  -- Let $a$ be such that $4^a \mid n$ and $4^{a+1} \nmid n$.
  obtain ⟨a, ha⟩ : ∃ a : ℕ, 4^a ∣ n ∧ ¬4^(a+1) ∣ n := by
    by_contra h_contra;
    -- If for every $a$, $4^a \mid n$, then $n$ would be divisible by arbitrarily high powers of 4, which contradicts $n$ being finite.
    have h_div_arbitrarily_high : ∀ a : ℕ, 4^a ∣ n := by
      exact fun a => Nat.recOn a ( by norm_num ) fun a ih => by push_neg at h_contra; exact h_contra a ih;
    exact absurd ( h_div_arbitrarily_high ( Nat.log 4 n + 1 ) ) ( Nat.not_dvd_of_pos_of_lt hn ( Nat.lt_pow_succ_log_self ( by decide ) _ ) );
  exact ⟨ a, n / 4 ^ a, by rw [ Nat.mul_div_cancel' ha.1 ], fun h => ha.2 <| by convert Nat.mul_dvd_mul_left ( 4 ^ a ) ( Nat.dvd_of_mod_eq_zero h ) using 1; rw [ Nat.mul_div_cancel' ha.1 ] ⟩

/-
Legendre's Three-Square Theorem: A natural number n is a sum of three squares if and only if n is not of the form 4^a(8b+7).
CONDITIONAL on Unimodular equivalence fact!
-/
theorem ConditionalLegendreThreeSquareTheorem (h_unimodular : UnimodularEquivalenceFact) (n : ℕ) :
    IsSumOfThreeSquares n ↔ ∀ a b : ℕ, n ≠ 4^a * (8 * b + 7) := by
  refine' ⟨ _, _ ⟩;
  · exact?;
  · intro hn
    by_cases hn_zero : n = 0;
    · exact ⟨ 0, 0, 0, by norm_num [ hn_zero ] ⟩;
    · -- By reduction_lemma, write n = 4^k * m with m % 4 != 0.
      obtain ⟨k, m, rfl, hm⟩ : ∃ k m : ℕ, n = 4^k * m ∧ m % 4 ≠ 0 := reduction_lemma n (Nat.pos_of_ne_zero hn_zero);
      -- Since m is not of the form 8b+7, we can apply Lemma 1.9 to find D and t such that t^2 = -D mod (Dm-1).
      obtain ⟨D, hD_pos, hDn, t, ht⟩ : ∃ D : ℕ, D > 0 ∧ D * m > 1 ∧ ∃ t : ℤ, t^2 ≡ -D [ZMOD ((D : ℤ) * m - 1)] := by
        apply existD m (Nat.pos_of_ne_zero (by
        aesop)) (by
        have := Nat.mod_lt m ( by decide : 0 < 8 ) ; interval_cases _ : m % 8 <;> simp_all +decide [ ← Nat.mod_mod_of_dvd m ( by decide : 4 ∣ 8 ) ] ;
        exact hn k ( m / 8 ) ( by nlinarith [ Nat.mod_add_div m 8, pow_pos ( by decide : 0 < 4 ) k ] ));
      -- By Lemma 1.8, the form F constructed from m, D, t is positive definite, has determinant 1, and represents m.
      obtain ⟨F, hF_pos, hF_det, hF_rep⟩ : ∃ F : IntegralTernaryQuadraticForm, F.PositiveDefinite ∧ F.det = 1 ∧ F.eval ![0, 0, 1] = m := by
        exact ⟨ constructedForm m D t, constructF m ( Nat.pos_of_ne_zero ( by aesop ) ) D hD_pos hDn t ht ⟩;
      -- Since F is properly equivalent to the sum of three squares, the sum of three squares represents m.
      have h_sum_squares_rep : ∃ x y z : ℤ, m = x^2 + y^2 + z^2 := by
        have h_sum_squares_rep : F.RepresentedSet = IntegralTernaryQuadraticForm.sum_squares.RepresentedSet := by
          exact?;
        replace h_sum_squares_rep := Set.ext_iff.mp h_sum_squares_rep m; aesop;
        obtain ⟨ y, hy ⟩ := h_sum_squares_rep.mp ⟨ _, hF_rep ⟩ ; use y 0, y 1, y 2; simp_all +decide [ IntegralTernaryQuadraticForm.eval ] ;
        simp_all +decide [ Matrix.vecMul, dotProduct, Fin.sum_univ_three ];
        unfold IntegralTernaryQuadraticForm.sum_squares at hy; simp_all +decide [ Matrix.vecHead, Matrix.vecTail ] ; ring;
        simp_all +decide [ IntegralTernaryQuadraticForm.toMatrix ] ; linarith;
      obtain ⟨ x, y, z, h ⟩ := h_sum_squares_rep; use x * 2 ^ k, y * 2 ^ k, z * 2 ^ k; push_cast [ ← @Nat.cast_inj ℤ ] ; rw [ h ] ; ring;
      norm_num [ pow_mul' ]

#check MeasureTheory.exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure

#check Real.pi_gt_three

#check MeasureTheory.exists_pair_mem_lattice_not_disjoint_vadd

#check EuclideanSpace.volume_closedBall

#check Real.map_matrix_volume_pi_eq_smul_volume_pi

/-
Definition of the ellipsoid associated to a matrix M and value t.
-/
def Ellipsoid {n : ℕ} (M : Matrix (Fin n) (Fin n) ℝ) (t : ℝ) : Set (Fin n → ℝ) :=
  { x | dotProduct x (Matrix.mulVec M x) ≤ t }

/-
The volume of the image of a set under a matrix transformation scales by the absolute value of the determinant.
-/
lemma volume_image_matrix {n : ℕ} [Fintype (Fin n)] [DecidableEq (Fin n)]
    (A : Matrix (Fin n) (Fin n) ℝ) (s : Set (Fin n → ℝ)) :
    MeasureTheory.volume ((Matrix.toLin' A) '' s) = ENNReal.ofReal (|A.det|) * MeasureTheory.volume s := by
      convert MeasureTheory.Measure.addHaar_image_linearMap _ _ _;
      · exact?;
      · infer_instance;
      · infer_instance;
      · infer_instance

/-
Existence of a square root matrix A for a positive definite matrix M such that M = A^T A and |det A| = sqrt(det M).
-/
lemma exists_sqrt_pos_def {n : ℕ} [Fintype (Fin n)] [DecidableEq (Fin n)]
    (M : Matrix (Fin n) (Fin n) ℝ) (hM : M.PosDef) :
    ∃ A : Matrix (Fin n) (Fin n) ℝ, M = A.transpose * A ∧ |A.det| = Real.sqrt M.det ∧ IsUnit A.det := by
      -- Let $A$ be the positive semidefinite square root of $M$ (Matrix.PosSemidef.sqrt).
      obtain ⟨A, hA⟩ : ∃ A : Matrix (Fin n) (Fin n) ℝ, M = A.transpose * A := by
        have h_sqrt : ∃ A : Matrix (Fin n) (Fin n) ℝ, M = A.transpose * A := by
          have h_pos_semidef : M.PosSemidef := by
            exact hM.posSemidef
          exact?;
        exact h_sqrt;
      refine' ⟨ A, hA, _, _ ⟩ <;> aesop;
      · rw [ Real.sqrt_mul_self_eq_abs ];
      · have := hM.det_pos; aesop;

#check Matrix.mulVec_mulVec

#check Matrix.vecMul_transpose

#check Matrix.dotProduct_mulVec

#check Matrix.transpose_nonsing_inv

#check Matrix.toLin'_apply

/-
For $M = A^T A$, the quadratic form $x^T M x$ is equal to the squared norm $\|Ax\|^2$ (expressed as dot product).
-/
lemma ellipsoid_norm_eq {n : ℕ} [Fintype (Fin n)] [DecidableEq (Fin n)]
    (M : Matrix (Fin n) (Fin n) ℝ) (A : Matrix (Fin n) (Fin n) ℝ)
    (hA : M = A.transpose * A) (x : Fin n → ℝ) :
    dotProduct x (Matrix.mulVec M x) = dotProduct (Matrix.mulVec A x) (Matrix.mulVec A x) := by
      simp +decide [ hA, Matrix.dotProduct_mulVec, Matrix.vecMul_mulVec ]

/-
The ellipsoid defined by $M=A^T A$ is the image of the Euclidean ball of radius $\sqrt{t}$ under the linear map defined by $A^{-1}$.
-/
def EuclideanClosedBall (n : ℕ) (r : ℝ) : Set (Fin n → ℝ) :=
  { x | Real.sqrt (dotProduct x x) ≤ r }

lemma ellipsoid_eq_image_ball_aux {n : ℕ} [Fintype (Fin n)] [DecidableEq (Fin n)]
    (M : Matrix (Fin n) (Fin n) ℝ) (t : ℝ) (ht : 0 ≤ t)
    (A : Matrix (Fin n) (Fin n) ℝ) (hA : M = A.transpose * A) (hA_unit : IsUnit A.det) :
    Ellipsoid M t = (Matrix.toLin' A⁻¹) '' (EuclideanClosedBall n (Real.sqrt t)) := by
      ext x
      simp [Ellipsoid, Matrix.toLin'_apply];
      bound;
      · refine' ⟨ A.mulVec x, _, _ ⟩;
        · simp_all +decide [ EuclideanClosedBall, Matrix.mulVec_mulVec, Matrix.dotProduct_mulVec, Matrix.vecMul_mulVec ];
          convert a using 1;
          convert rfl;
        · simp +decide [ hA_unit.ne_zero, isUnit_iff_ne_zero ];
      · have h_norm : dotProduct (A.mulVec (A⁻¹.mulVec w)) (A.mulVec (A⁻¹.mulVec w)) ≤ t := by
          convert left using 1;
          unfold EuclideanClosedBall; aesop;
          · exact?;
          · convert a using 1;
            convert rfl;
        convert h_norm using 1;
        simp +decide [ Matrix.dotProduct_mulVec, Matrix.vecMul_mulVec, Matrix.mul_assoc ];
        congr!

#check EuclideanSpace

#check WithLp

#print EuclideanSpace

#print WithLp

#check EuclideanSpace.norm_eq

#check MeasureTheory.Measure.addHaar_closedBall

#check Real.norm_eq_abs

#check sq_abs

#check Real.sq_sqrt

/-
The dot product of a vector in Euclidean space with itself is equal to its squared norm.
-/
lemma dotProduct_eq_norm_sq {n : ℕ} [Fintype (Fin n)] (x : EuclideanSpace ℝ (Fin n)) :
    dotProduct x x = ‖x‖ ^ 2 := by
      norm_num [ EuclideanSpace.norm_eq ];
      rw [ Real.sq_sqrt <| Finset.sum_nonneg fun _ _ => sq_nonneg _, dotProduct ];
      exact Finset.sum_congr rfl fun _ _ => by ring;

/-
The Euclidean closed ball defined by dot product is equal to the metric closed ball defined by norm.
-/
lemma euclidean_closed_ball_eq_metric_closed_ball {n : ℕ} [Fintype (Fin n)] (r : ℝ) :
    EuclideanClosedBall n r = Metric.closedBall (0 : EuclideanSpace ℝ (Fin n)) r := by
      ext; simp [EuclideanClosedBall];
      rw [ EuclideanSpace.dist_eq ];
      norm_num [ dotProduct, dist_eq_norm ];
      field_simp;
      congr!

#check Matrix.toLin'_mul

#check Matrix.toLin'_one

/-
Blichfeldt's Lemma: Let $S\subset \R^n$ be measurable. If $\vol(S)>1$, then there exist distinct $x,y\in S$ with $x-y\in \Z^n\setminus\{0\}$.
-/
lemma blichfeldt_lemma {n : ℕ} (S : Set (Fin n → ℝ)) (hS_meas : MeasurableSet S)
    (h_vol : MeasureTheory.volume S > 1) :
    ∃ x y : Fin n → ℝ, x ∈ S ∧ y ∈ S ∧ x ≠ y ∧ ∀ i, ∃ k : ℤ, x i - y i = k := by
      -- Let $Q = [0,1)^n$ be the unit cube.
      set Q : Set (Fin n → ℝ) := Set.pi Set.univ fun _ => Set.Ico 0 1;
      -- For each $m \in \mathbb{Z}^n$, let $S_m = S \cap (m + Q)$. Then $\text{vol}(S) = \sum_{m \in \mathbb{Z}^n} \text{vol}(S_m)$.
      have h_decomp : MeasureTheory.volume S = ∑' m : (Fin n) → ℤ, MeasureTheory.volume (S ∩ (Set.image (fun x => x + (fun i => (m i : ℝ))) Q)) := by
        rw [ ← MeasureTheory.measure_iUnion ];
        · congr with x ; aesop;
          exact ⟨ fun i => ⌊x i⌋, fun i => ⟨ Int.floor_le _, by linarith [ Int.lt_floor_add_one ( x i ) ] ⟩ ⟩;
        · intro m m' h; simp +decide [ Set.disjoint_left ] ; contrapose! h; aesop;
          exact funext fun i => Int.le_antisymm ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; linarith [ left_1 i, right i ] ) ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; linarith [ left_1 i, right i ] );
        · intro m; exact MeasurableSet.inter hS_meas ( by
            rw [ Set.image_add_right ];
            exact MeasurableSet.preimage ( show MeasurableSet Q from by exact MeasurableSet.univ_pi fun _ => measurableSet_Ico ) ( measurable_id.add_const _ ) ) ;
      -- If all the sets $T_m$ were pairwise disjoint, then $\sum_{m \in \mathbb{Z}^n} \text{vol}(T_m) \leq \text{vol}(Q) = 1$, contradicting $\sum_{m \in \mathbb{Z}^n} \text{vol}(T_m) = \text{vol}(S) > 1$.
      by_contra h_contra
      have h_disjoint : ∀ m m' : (Fin n) → ℤ, m ≠ m' → Disjoint (Set.image (fun x => x - (fun i => (m i : ℝ))) (S ∩ (Set.image (fun x => x + (fun i => (m i : ℝ))) Q))) (Set.image (fun x => x - (fun i => (m' i : ℝ))) (S ∩ (Set.image (fun x => x + (fun i => (m' i : ℝ))) Q))) := by
        intros m m' h_ne; rw [ Set.disjoint_left ] ; contrapose! h_ne; aesop;
        ext i; specialize h_contra w left w_1 left_1; simp_all +decide [ funext_iff, sub_eq_iff_eq_add ] ;
        exact Classical.not_not.1 fun hi => by obtain ⟨ j, hj ⟩ := h_contra i ( by intro H; exact hi <| by exact_mod_cast ( by linarith [ right_1 i, right_2 i ] : ( m i : ℝ ) = m' i ) ) ; exact hj ( m j - m' j ) <| by push_cast; ring;
      have h_sum_le_one : ∑' m : (Fin n) → ℤ, MeasureTheory.volume (Set.image (fun x => x - (fun i => (m i : ℝ))) (S ∩ (Set.image (fun x => x + (fun i => (m i : ℝ))) Q))) ≤ MeasureTheory.volume Q := by
        rw [ ← MeasureTheory.measure_iUnion ];
        · refine' MeasureTheory.measure_mono _;
          simp +decide [ Set.subset_def ];
          bound;
        · exact fun m m' h => h_disjoint m m' h;
        · intro m; rw [ Set.image_eq_preimage_of_inverse ];
          rotate_right;
          use fun x => x + fun i => ( m i : ℝ );
          · norm_num +zetaDelta at *;
            exact MeasurableSet.inter ( hS_meas.preimage ( measurable_id.add_const _ ) ) ( MeasurableSet.preimage ( show MeasurableSet ( ( fun x => x + -fun i => ( m i : ℝ ) ) ⁻¹' Set.univ.pi fun x => Set.Ico 0 1 ) from by exact MeasurableSet.preimage ( show MeasurableSet ( Set.univ.pi fun x => Set.Ico 0 1 ) from by exact MeasurableSet.univ_pi fun _ => measurableSet_Ico ) ( measurable_id.add_const _ ) ) ( measurable_id.add_const _ ) );
          · exact fun x => by simp +decide ;
          · exact fun x => by simp +decide [ sub_eq_add_neg ] ;
      -- Since translation preserves volume, we have $\text{vol}(T_m) = \text{vol}(S_m)$ for each $m$.
      have h_volume_eq : ∀ m : (Fin n) → ℤ, MeasureTheory.volume (Set.image (fun x => x - (fun i => (m i : ℝ))) (S ∩ (Set.image (fun x => x + (fun i => (m i : ℝ))) Q))) = MeasureTheory.volume (S ∩ (Set.image (fun x => x + (fun i => (m i : ℝ))) Q)) := by
        bound;
        erw [ Set.image_add_right ];
        erw [ MeasureTheory.measure_preimage_add_right ];
      simp_all +decide [ MeasureTheory.volume_pi ];
      exact h_vol.not_le <| h_sum_le_one.trans <| by erw [ MeasureTheory.Measure.pi_pi ] ; norm_num [ Q ] ;

/-
Minkowski's Theorem: Let $K\subset \R^n$ be a centrally symmetric convex body. If $\vol(K)>2^n$, then $K$ contains a nonzero point of $\Z^n$.
-/
lemma minkowski_theorem {n : ℕ} (K : Set (Fin n → ℝ)) (hK_symm : ∀ x ∈ K, -x ∈ K)
    (hK_conv : Convex ℝ K) (hK_meas : MeasurableSet K) (h_vol : MeasureTheory.volume K > 2^n) :
    ∃ x : Fin n → ℝ, x ∈ K ∧ x ≠ 0 ∧ ∀ i, ∃ k : ℤ, x i = k := by
      -- Set $S=\tfrac12 K$. Then $S$ is measurable and $\vol(S)=\vol(K)/2^n>1$.
      set S := (fun x => (1 / 2 : ℝ) • x) '' K
      have hS_meas : MeasurableSet S := by
        convert hK_meas.preimage ( show Measurable fun x : Fin n → ℝ => ( 2 : ℝ ) • x by exact measurable_const.smul measurable_id' ) using 1 ; ext ; aesop;
        · cases a ; aesop;
        · exact ⟨ 2 • x, a, by ext i; norm_num; ring ⟩
      have hS_vol : MeasureTheory.volume S > 1 := by
        have hS_volume : MeasureTheory.volume S = ENNReal.ofReal ((1 / 2 : ℝ) ^ n) * MeasureTheory.volume K := by
          simp +zetaDelta at *;
        rw [ hS_volume, mul_comm ];
        refine' lt_of_le_of_lt _ ( ENNReal.mul_lt_mul_right _ _ |>.2 h_vol ) <;> norm_num;
        rw [ ← mul_pow, ENNReal.ofReal_div_of_pos ] <;> norm_num;
        rw [ ENNReal.mul_inv_cancel ] <;> norm_num;
      -- By Lemma~\ref{lem:blichfeldt} there exist $x\neq y$ in $S$ with $m=x-y\in \Z^n\setminus\{0\}$.
      obtain ⟨x, y, hxS, hyS, hxy_ne, hxy_int⟩ : ∃ x y : (Fin n) → ℝ, x ∈ S ∧ y ∈ S ∧ x ≠ y ∧ ∀ i, ∃ k : ℤ, x i - y i = k := by
        have := blichfeldt_lemma S hS_meas hS_vol; aesop;
      rcases hxS with ⟨ a, ha, rfl ⟩ ; rcases hyS with ⟨ b, hb, rfl ⟩ ; use ( 1 / 2 : ℝ ) • a - ( 1 / 2 : ℝ ) • b; norm_num [ sub_eq_iff_eq_add ] at * ; aesop;
      convert hK_conv ha ( hK_symm b hb ) ( show ( 0 : ℝ ) ≤ 1 / 2 by norm_num ) ( show ( 0 : ℝ ) ≤ 1 / 2 by norm_num ) ( by norm_num ) using 1 ; ext i ; norm_num ; ring

/-
$\pi > 3$.
-/
lemma pi_gt_three : Real.pi > 3 := by
  exact Real.pi_gt_three

/-
Volume of an ellipsoid $E_M(t)$ is $\vol(B_n(1)) t^{n/2} / \sqrt{\det M}$.
-/
lemma ellipsoid_volume {n : ℕ} (M : Matrix (Fin n) (Fin n) ℝ) (hM : M.PosDef) (t : ℝ) (ht : 0 < t) :
    MeasureTheory.volume (Ellipsoid M t) = MeasureTheory.volume (EuclideanClosedBall n 1) * (ENNReal.ofReal (t ^ ((n : ℝ) / 2))) / ENNReal.ofReal (Real.sqrt M.det) := by
      -- Choose an invertible $A$ with $M=A^T A$ (e.g.\ Cholesky). Then $\mathbf{x}^T M\mathbf{x}=\|A\mathbf{x}\|^2$ and
      obtain ⟨A, hA⟩ : ∃ A : Matrix (Fin n) (Fin n) ℝ, M = A.transpose * A ∧ |A.det| = Real.sqrt M.det := by
        have := exists_sqrt_pos_def M hM;
        aesop;
      -- By the change-of-variables formula, the volume of the ellipsoid is given by
      have h_volume_formula : MeasureTheory.volume (Ellipsoid M t) = MeasureTheory.volume ((Matrix.toLin' A⁻¹) '' (EuclideanClosedBall n (Real.sqrt t))) := by
        have h_volume_formula : Ellipsoid M t = (Matrix.toLin' A⁻¹) '' (EuclideanClosedBall n (Real.sqrt t)) := by
          apply ellipsoid_eq_image_ball_aux;
          · positivity;
          · exact hA.1;
          · have := hM.det_pos;
            exact isUnit_iff_ne_zero.mpr fun h => by norm_num [ h ] at hA; linarith [ Real.sqrt_pos.mpr this ] ;
        rw [h_volume_formula];
      -- The volume of the ball of radius $\sqrt{t}$ is $\vol(B_n(1)) (\sqrt{t})^n$.
      have h_ball_volume : MeasureTheory.volume (EuclideanClosedBall n (Real.sqrt t)) = MeasureTheory.volume (EuclideanClosedBall n 1) * ENNReal.ofReal (t ^ (n / 2 : ℝ)) := by
        have h_ball_volume : ∀ r : ℝ, 0 < r → MeasureTheory.volume (EuclideanClosedBall n r) = MeasureTheory.volume (EuclideanClosedBall n 1) * ENNReal.ofReal (r ^ n) := by
          intro r hr
          have h_ball_volume : MeasureTheory.volume (EuclideanClosedBall n r) = MeasureTheory.volume (r • EuclideanClosedBall n 1) := by
            congr with x ; simp +decide [ EuclideanClosedBall ];
            rw [ Set.mem_smul_set_iff_inv_smul_mem₀ hr.ne' ] ; norm_num [ Real.sqrt_le_iff, hr.le ] ; ring;
            field_simp;
          norm_num +zetaDelta at *;
          rw [ h_ball_volume, mul_comm, abs_of_pos hr, ENNReal.ofReal_pow hr.le ];
        convert h_ball_volume ( Real.sqrt t ) ( Real.sqrt_pos.mpr ht ) using 2 ; rw [ Real.sqrt_eq_rpow, ← Real.rpow_natCast, ← Real.rpow_mul ht.le ] ; ring;
      -- The volume of the image of a set under a linear transformation is given by the absolute value of the determinant of the transformation times the volume of the set.
      have h_image_volume : ∀ (T : (Fin n → ℝ) →ₗ[ℝ] (Fin n → ℝ)) (S : Set (Fin n → ℝ)), MeasureTheory.volume (T '' S) = ENNReal.ofReal (|T.det|) * MeasureTheory.volume S := by
        exact?;
      specialize h_image_volume ( Matrix.toLin' A⁻¹ ) ( EuclideanClosedBall n ( Real.sqrt t ) ) ; aesop;
      rw [ ENNReal.ofReal_inv_of_pos ( Real.sqrt_pos.mpr ( mul_self_pos.mpr ( show A.det ≠ 0 from fun h => by simpa [ h ] using hM.det_pos ) ) ) ] ; ring;
      rw [ ENNReal.div_eq_inv_mul ] ; ring

/-
A primitive vector in $\Z^3$ can be mapped to $e_1$ by an element of $\SL_3(\Z)$. Equivalently, it can be the first column of a matrix in $\SL_3(\Z)$.
-/
lemma primitive_to_e1 (v : Fin 3 → ℤ) (hv : Finset.gcd Finset.univ v = 1) :
    ∃ A : Matrix.SpecialLinearGroup (Fin 3) ℤ, Matrix.mulVec A.1 (Pi.basisFun ℤ (Fin 3) 0) = v := by
      -- Let $v = (a, b, c)^T$. Let $d = \gcd(a, b)$.
      obtain ⟨d, hd⟩ : ∃ d : ℤ, d ∣ v 0 ∧ d ∣ v 1 ∧ ∃ x y : ℤ, x * v 0 + y * v 1 = d := by
        exact ⟨ Int.gcd ( v 0 ) ( v 1 ), Int.gcd_dvd_left _ _, Int.gcd_dvd_right _ _, Int.gcd_eq_gcd_ab ( v 0 ) ( v 1 ) ▸ ⟨ Int.gcdA _ _, Int.gcdB _ _, by ring ⟩ ⟩;
      -- Construct $P \in \SL_2(\Z)$ such that $P (a, b)^T = (d, 0)^T$.
      obtain ⟨P, hP⟩ : ∃ P : Matrix (Fin 2) (Fin 2) ℤ, P.det = 1 ∧ P.mulVec ![v 0, v 1] = ![d, 0] := by
        obtain ⟨ hd₀, hd₁, x, y, hxy ⟩ := hd;
        cases' hd₀ with k hk;
        cases' hd₁ with l hl;
        by_cases hd : d = 0 <;> simp_all +decide [ mul_comm ];
        · exact ⟨ 1, by norm_num ⟩;
        · -- Let $P = \begin{pmatrix} x & y \\ -l & k \end{pmatrix}$.
          use !![x, y; -l, k];
          exact ⟨ by norm_num; cases lt_or_gt_of_ne hd <;> nlinarith, by ext i ; fin_cases i <;> norm_num <;> cases lt_or_gt_of_ne hd <;> nlinarith ⟩;
      -- Embed $P$ into $U_1 \in \SL_3(\Z)$ as $\begin{pmatrix} P & 0 \\ 0 & 1 \end{pmatrix}$.
      obtain ⟨U1, hU1⟩ : ∃ U1 : Matrix.SpecialLinearGroup (Fin 3) ℤ, U1.val.mulVec ![v 0, v 1, v 2] = ![d, 0, v 2] := by
        -- Let $U_1 = \begin{pmatrix} P & 0 \\ 0 & 1 \end{pmatrix}$.
        use ⟨Matrix.of ![![P 0 0, P 0 1, 0], ![P 1 0, P 1 1, 0], ![0, 0, 1]], by
          simp +decide [ Matrix.det_fin_three, hP.1 ];
          rw [ ← hP.1, Matrix.det_fin_two ]⟩
        generalize_proofs at *;
        simp_all +decide [ ← List.ofFn_inj, Matrix.mulVec ];
        exact ⟨ by simpa [ Matrix.vecHead, Matrix.vecTail, mul_comm ] using hP.2.1, by simpa [ Matrix.vecHead, Matrix.vecTail, mul_comm ] using hP.2.2 ⟩;
      -- Now consider the vector $(d, c)^T$. Since $\gcd(a, b, c) = 1$, we have $\gcd(d, c) = 1$.
      have h_coprime : Int.gcd d (v 2) = 1 := by
        refine' Nat.coprime_of_dvd' _;
        intro k hk hk₁ hk₂; have := Int.natCast_dvd.mpr hk₁; have := Int.natCast_dvd.mpr hk₂; simp_all +decide [ ← Int.natCast_dvd_natCast, Fin.univ_succ ] ;
        exact hv ▸ Int.dvd_coe_gcd ( Int.dvd_trans ‹_› hd.1 ) ( Int.dvd_coe_gcd ( Int.dvd_trans ‹_› hd.2.1 ) ( by simpa [ normalize ] using this ) );
      -- Construct $Q \in \SL_2(\Z)$ such that $Q (d, c)^T = (1, 0)^T$.
      obtain ⟨Q, hQ⟩ : ∃ Q : Matrix (Fin 2) (Fin 2) ℤ, Q.det = 1 ∧ Q.mulVec ![d, v 2] = ![1, 0] := by
        have := Int.gcd_eq_gcd_ab d ( v 2 );
        use !![Int.gcdA d (v 2), Int.gcdB d (v 2); -v 2, d];
        exact ⟨ by norm_num [ Matrix.det_fin_two ] ; linarith, by ext i; fin_cases i <;> norm_num [ Matrix.mulVec ] <;> linarith ⟩;
      -- Embed $Q$ into $U_2 \in \SL_3(\Z)$ acting on indices 0 and 2.
      obtain ⟨U2, hU2⟩ : ∃ U2 : Matrix.SpecialLinearGroup (Fin 3) ℤ, U2.val.mulVec ![d, 0, v 2] = ![1, 0, 0] := by
        -- Construct $U_2$ as $\begin{pmatrix} Q & 0 \\ 0 & 1 \end{pmatrix}$.
        use ⟨Matrix.of ![![Q 0 0, 0, Q 0 1], ![0, 1, 0], ![Q 1 0, 0, Q 1 1]], by
          simp_all +decide [ Matrix.det_fin_three ];
          rw [ ← hQ.1, Matrix.det_fin_two ]⟩
        generalize_proofs at *;
        simp_all +decide [ ← List.ofFn_inj, Matrix.mulVec ];
        exact ⟨ by linarith! [ hQ.2.1 ], by linarith! [ hQ.2.2 ] ⟩;
      -- Let $U = U_2 U_1$. Then $U \in \SL_3(\Z)$ and $U v = e_1$.
      obtain ⟨U, hU⟩ : ∃ U : Matrix.SpecialLinearGroup (Fin 3) ℤ, U.val.mulVec ![v 0, v 1, v 2] = ![1, 0, 0] := by
        use U2 * U1;
        simp_all +decide [ ← Matrix.mulVec_mulVec ];
      -- Let $A = U^{-1}$. Then $A e_1 = v$.
      use U⁻¹;
      convert congr_arg ( fun x => ( U⁻¹ : Matrix ( Fin 3 ) ( Fin 3 ) ℤ ).mulVec x ) hU using 1;
      · simp +decide [ hU ];
        simp +decide [ Matrix.inv_def, Matrix.mulVec ];
        ext i; fin_cases i <;> simp +decide [ Matrix.mulVec ] ;
        · rfl;
        · rfl;
        · rfl;
      · rw [ ← hU, Matrix.mulVec_mulVec ];
        erw [ Matrix.nonsing_inv_mul _ ] <;> norm_num;
        exact funext fun i => by fin_cases i <;> rfl;

#check finSumFinEquiv

#check Matrix.row

#check Matrix.col

#check Matrix.fromBlocks

/-
Shearing to remove a first row/column: A specific shearing matrix $S$ transforms $M$ to a block diagonal form.
-/
lemma shear_lemma (r : Fin 2 → ℤ) (C : Matrix (Fin 2) (Fin 2) ℤ) :
    let e := @finSumFinEquiv 1 2
    let row_r : Matrix (Fin 1) (Fin 2) ℤ := Matrix.of fun _ j => r j
    let col_r : Matrix (Fin 2) (Fin 1) ℤ := Matrix.of fun i _ => r i
    let row_neg_r : Matrix (Fin 1) (Fin 2) ℤ := Matrix.of fun _ j => -r j
    let M_block := Matrix.fromBlocks !![1] row_r col_r C
    let S_block := Matrix.fromBlocks !![1] row_neg_r 0 1
    let M : Matrix (Fin 3) (Fin 3) ℤ := Matrix.reindex e e M_block
    let S : Matrix (Fin 3) (Fin 3) ℤ := Matrix.reindex e e S_block
    S.det = 1 ∧ S.transpose * M * S = Matrix.reindex e e (Matrix.fromBlocks !![1] 0 0 (C - col_r * row_r)) := by
      unfold finSumFinEquiv;
      simp +decide [ Matrix.det_fin_two, Matrix.det_fin_three ];
      simp +decide [ Fin.addCases, Matrix.mul_apply ];
      ext i j ; fin_cases i <;> fin_cases j <;> simp +decide [ Matrix.mul_apply, Fin.sum_univ_succ ];
      all_goals simp +decide [ Matrix.one_apply, Fin.ext_iff ] ;
      · grind;
      · ring;
      · ring;
      · grind

/-
Let $F(\mathbf{x})=\mathbf{x}^T M\mathbf{x}$ be a positive-definite integral ternary quadratic form with $\det(M)=1$. Then there exists $v\in\Z^3\setminus\{0\}$ with $F(v)=1$.
-/
lemma unit3 (F : IntegralTernaryQuadraticForm) (h_pos : F.PositiveDefinite) (h_det : F.det = 1) :
    ∃ v : Fin 3 → ℤ, v ≠ 0 ∧ F.eval v = 1 := by
      -- By Lemma 1, the volume of the ellipsoid $E$ is $\frac{256\pi}{81} > 8 = 2^3$.
      have h_volume : MeasureTheory.volume (Ellipsoid (F.toMatrix.map (Int.castRingHom ℝ)) (16 / 9 : ℝ)) > 2^3 := by
        have h_volume : MeasureTheory.volume (Ellipsoid (F.toMatrix.map (Int.castRingHom ℝ)) (16 / 9)) = MeasureTheory.volume (EuclideanClosedBall 3 1) * (ENNReal.ofReal ((16 / 9 : ℝ) ^ (3 / 2 : ℝ))) := by
          convert ellipsoid_volume ( F.toMatrix.map ( Int.castRingHom ℝ ) ) h_pos ( 16 / 9 : ℝ ) ( by norm_num ) using 1;
          norm_num [ Matrix.det_fin_three ] at *;
          unfold IntegralTernaryQuadraticForm.det at h_det; norm_cast at *; aesop;
          unfold IntegralTernaryQuadraticForm.toMatrix at *; norm_num [ Matrix.det_fin_three ] at *; aesop;
          norm_cast ; aesop;
        -- The volume of the unit ball in 3 dimensions is $\frac{4\pi}{3}$.
        have h_unit_ball : MeasureTheory.volume (EuclideanClosedBall 3 1) = ENNReal.ofReal (4 * Real.pi / 3) := by
          have := @MeasureTheory.volume_sum_rpow_le ( Fin 3 );
          convert @this ( inferInstance ) ( inferInstance ) 2 ( by norm_num ) 1 using 1 <;> norm_num;
          · congr with x ; norm_num [ ← Real.sqrt_eq_rpow, EuclideanClosedBall ];
            norm_num [ sq, dotProduct ];
          · rw [ show ( 5 / 2 : ℝ ) = 3 / 2 + 1 by norm_num, Real.Gamma_add_one ( by norm_num ), show ( 3 / 2 : ℝ ) = 1 / 2 + 1 by norm_num, Real.Gamma_add_one ( by norm_num ), Real.Gamma_one_half_eq ] ; ring ; norm_num [ Real.pi_pos.le ];
            rw [ ← ENNReal.ofReal_mul ( by positivity ) ] ; norm_num [ pow_three, mul_assoc, mul_comm, mul_left_comm, Real.pi_pos.le, ne_of_gt Real.pi_pos ];
        rw [ h_volume, h_unit_ball, ← ENNReal.ofReal_mul ] <;> norm_num;
        · rw [ show ( 16 / 9 : ℝ ) ^ ( 3 / 2 : ℝ ) = ( 16 / 9 : ℝ ) * Real.sqrt ( 16 / 9 ) by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ] ; nlinarith [ Real.pi_gt_three, Real.sqrt_nonneg ( 16 / 9 ), Real.sq_sqrt ( show 0 ≤ 16 / 9 by norm_num ) ];
        · positivity;
      -- By Minkowski's theorem, there exists a nonzero integer point $v$ in the ellipsoid $E$.
      obtain ⟨v, hv_ne_zero, hv_in_E⟩ : ∃ v : Fin 3 → ℤ, v ≠ 0 ∧ (dotProduct (fun i => (v i : ℝ)) (Matrix.mulVec (F.toMatrix.map (Int.castRingHom ℝ)) (fun i => (v i : ℝ)))) ≤ 16 / 9 := by
        have := @minkowski_theorem;
        specialize this ( Ellipsoid ( F.toMatrix.map ( Int.castRingHom ℝ ) ) ( 16 / 9 ) ) ?_ ?_ ?_ h_volume <;> norm_num at *;
        · unfold Ellipsoid; aesop;
          simp_all ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct ];
        · refine' convex_iff_forall_pos.mpr _;
          unfold Ellipsoid; aesop;
          -- Since $M$ is positive definite, we have $x^T M y \leq \frac{1}{2} (x^T M x + y^T M y)$.
          have h_pos_def : ∀ x y : Fin 3 → ℝ, dotProduct x (Matrix.mulVec (F.toMatrix.map (Int.castRingHom ℝ)) y) ≤ (1 / 2) * (dotProduct x (Matrix.mulVec (F.toMatrix.map (Int.castRingHom ℝ)) x) + dotProduct y (Matrix.mulVec (F.toMatrix.map (Int.castRingHom ℝ)) y)) := by
            intros x y
            have h_dot_prod : (x - y) ⬝ᵥ (F.toMatrix.map (Int.castRingHom ℝ)).mulVec (x - y) ≥ 0 := by
              have := h_pos.2 ( x - y ) ; aesop;
              exact if h : x - y = 0 then by norm_num [ h ] else le_of_lt ( this h );
            norm_num [ Matrix.mulVec, dotProduct ] at *;
            norm_num [ Fin.sum_univ_three ] at * ; linarith! [ sq_nonneg ( x 0 - y 0 ), sq_nonneg ( x 1 - y 1 ), sq_nonneg ( x 2 - y 2 ) ] ;
          field_simp;
          norm_num [ Matrix.mulVec_add, Matrix.mulVec_smul ] at *;
          nlinarith [ mul_pos a_3 a_4, h_pos_def x y, h_pos_def y x, mul_le_mul_of_nonneg_left a ( show 0 ≤ a_2 by linarith ), mul_le_mul_of_nonneg_left a_1 ( show 0 ≤ a_2 by linarith ), mul_le_mul_of_nonneg_left a ( show 0 ≤ b by linarith ), mul_le_mul_of_nonneg_left a_1 ( show 0 ≤ b by linarith ) ];
        · refine' measurableSet_le _ _ <;> norm_num [ Matrix.mulVec, dotProduct ];
          fun_prop (disch := norm_num);
        · obtain ⟨ x, hx₁, hx₂, hx₃ ⟩ := this; choose k hk using hx₃; use fun i => k i; aesop;
          · exact hx₂ ( funext hk );
          · field_simp;
            convert mul_le_mul_of_nonneg_right hx₁ ( by norm_num : ( 0 : ℝ ) ≤ 9 ) using 1 ; norm_num [ ← hk, dotProduct ] ; ring;
      -- Since $F(v) \in \mathbb{Z}$ and $16/9 < 2$, this forces $F(v) = 1$.
      have hv_eval : F.eval v ≤ 1 := by
        unfold IntegralTernaryQuadraticForm.eval;
        norm_num [ Matrix.vecMul, dotProduct ] at *;
        norm_num [ Fin.sum_univ_three, Matrix.mulVec ] at *;
        norm_num [ Fin.sum_univ_three, dotProduct ] at hv_in_E;
        exact Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; linarith );
      have hv_pos : 0 < F.eval v := by
        have := h_pos.2 ( fun i => ( v i : ℝ ) ) ; aesop;
        convert this ( by simpa [ funext_iff ] using hv_ne_zero ) using 1 ; unfold IntegralTernaryQuadraticForm.eval ; aesop;
        · convert a using 1;
          norm_num [ Matrix.vecMul, dotProduct ];
          norm_num [ Matrix.mulVec, dotProduct, Fin.sum_univ_three ];
          norm_cast ; ring;
        · convert a using 1 ; norm_num [ Matrix.vecMul, dotProduct ] ; ring!; aesop;
          convert a_1 using 1 ; norm_num [ Matrix.mulVec, dotProduct ] ; ring!; aesop;
          convert a_2 using 1 ; norm_cast ; simp +decide [ mul_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] ; ring!; aesop;
      exact ⟨ v, hv_ne_zero, le_antisymm hv_eval hv_pos ⟩

/-
Let $Q(\mathbf{y})=\mathbf{y}^T B\mathbf{y}$ be a positive-definite integral binary quadratic form with $\det(B)=1$. Then there exists $u\in\Z^2\setminus\{0\}$ with $Q(u)=1$.
-/
lemma unit2 (B : Matrix (Fin 2) (Fin 2) ℤ) (h_pos : (B.map (Int.castRingHom ℝ)).PosDef) (h_det : B.det = 1) :
    ∃ u : Fin 2 → ℤ, u ≠ 0 ∧ (Matrix.vecMul u B) ⬝ᵥ u = 1 := by
      -- Let $E=\{\mathbf{y}\in\R^2:\mathbf{y}^T B\mathbf{y}\le 16/9\}$. By Lemma~\ref{lem:ellipsoidvol},
      let E := {y : Fin 2 → ℝ | dotProduct y (Matrix.mulVec (B.map (Int.castRingHom ℝ)) y) ≤ 16 / 9};
      -- By Lemma~\ref{lem:ellipsoidvol}, $\vol(E)=\pi\cdot \frac{16}{9}$.
      have h_volume : MeasureTheory.volume E > 2^2 := by
        -- Applying the lemma about the volume of ellipsoids, we get that the volume of $E$ is $\pi \cdot \frac{16}{9}$.
        have h_volume_E : MeasureTheory.volume E = ENNReal.ofReal (Real.pi * (16 / 9)) := by
          have := ellipsoid_volume ( B.map ( Int.castRingHom ℝ ) ) h_pos ( 16 / 9 ) ( by norm_num );
          -- The volume of the Euclidean closed ball of radius 1 in 2 dimensions is π.
          have h_ball_volume : MeasureTheory.volume (EuclideanClosedBall 2 1) = ENNReal.ofReal Real.pi := by
            convert ( MeasureTheory.volume_sum_rpow_le _ _ _ ) using 1 <;> norm_num;
            rotate_left;
            rotate_left;
            exact Fin 2;
            exact?;
            exact ⟨ 0 ⟩;
            exact 2;
            all_goals norm_num [ Real.Gamma_one_half_eq, Real.Gamma_add_one ];
            exact 1;
            · norm_num [ ← Real.sqrt_eq_rpow, EuclideanClosedBall ];
              norm_num [ sq ];
            · rw [ show ( 3 / 2 : ℝ ) = 1 / 2 + 1 by norm_num, Real.Gamma_add_one ( by norm_num ), Real.Gamma_one_half_eq ] ; ring ; norm_num [ Real.pi_pos.le ];
          rw [ ENNReal.ofReal_mul ( by positivity ) ] ; aesop;
          convert this using 1;
          · congr with x ; simp +decide [ Matrix.mulVec, dotProduct ];
          · erw [ show ( B.map fun x : ℤ => ( x : ℝ ) ).det = 1 by simpa [ Matrix.det_fin_two ] using congr_arg ( ( ↑ ) : ℤ → ℝ ) h_det ] ; norm_num;
        rw [ h_volume_E, gt_iff_lt, ENNReal.lt_ofReal_iff_toReal_lt ] <;> norm_num;
        linarith [ Real.pi_gt_three ];
      -- By Minkowski's theorem (Theorem~\ref{thm:minkowski}) there exists $u\in \Z^2\setminus\{0\}$ with $Q(u)\le 16/9$.
      obtain ⟨u, hu⟩ : ∃ u : Fin 2 → ℤ, u ≠ 0 ∧ (Matrix.vecMul (fun i => (u i : ℝ)) (B.map (Int.castRingHom ℝ))) ⬝ᵥ (fun i => (u i : ℝ)) ≤ 16 / 9 := by
        -- Apply Minkowski's theorem to the set $E$.
        have h_minkowski : ∃ x ∈ E, x ≠ 0 ∧ ∀ i, ∃ k : ℤ, x i = k := by
          apply_rules [ minkowski_theorem ];
          · aesop;
            norm_num [ Matrix.mulVec ] at * ; linarith;
          · -- The quadratic form $y^T B y$ is convex because $B$ is positive definite.
            have h_convex : Convex ℝ (fun y : Fin 2 → ℝ => dotProduct y (Matrix.mulVec (B.map (Int.castRingHom ℝ)) y) ≤ 16 / 9) := by
              have h_pos_def : Matrix.PosDef (B.map (Int.castRingHom ℝ)) := h_pos
              have h_convex : ∀ x y : Fin 2 → ℝ, ∀ t : ℝ, 0 ≤ t → t ≤ 1 → dotProduct (t • x + (1 - t) • y) (Matrix.mulVec (B.map (Int.castRingHom ℝ)) (t • x + (1 - t) • y)) ≤ t * dotProduct x (Matrix.mulVec (B.map (Int.castRingHom ℝ)) x) + (1 - t) * dotProduct y (Matrix.mulVec (B.map (Int.castRingHom ℝ)) y) := by
                intro x y t ht_nonneg ht_le_one
                have h_convex : dotProduct (t • x + (1 - t) • y) (Matrix.mulVec (B.map (Int.castRingHom ℝ)) (t • x + (1 - t) • y)) = t^2 * dotProduct x (Matrix.mulVec (B.map (Int.castRingHom ℝ)) x) + (1 - t)^2 * dotProduct y (Matrix.mulVec (B.map (Int.castRingHom ℝ)) y) + 2 * t * (1 - t) * dotProduct x (Matrix.mulVec (B.map (Int.castRingHom ℝ)) y) := by
                  simp +decide [ Matrix.mulVec, dotProduct, Fin.sum_univ_two ] ; ring;
                  have := h_pos_def.1; simp_all +decide [ Matrix.PosDef ] ;
                  have := congr_fun ( congr_fun h_pos.1 0 ) 1; norm_num [ Matrix.mulVec ] at this; ring_nf at *; aesop;
                  ring;
                have h_convex : dotProduct (x - y) (Matrix.mulVec (B.map (Int.castRingHom ℝ)) (x - y)) ≥ 0 := by
                  have := h_pos_def.2 ( x - y ) ; aesop;
                  exact if h : x - y = 0 then by norm_num [ h ] else le_of_lt ( this h );
                simp_all +decide [ Matrix.mulVec, dotProduct ];
                nlinarith [ mul_nonneg ht_nonneg ( sub_nonneg_of_le ht_le_one ) ];
              intros x hx y hy a b ha hb hab;
              specialize h_convex x y a ha ( by linarith );
              exact show ( a • x + b • y ) ⬝ᵥ ( B.map ( Int.castRingHom ℝ ) |> Matrix.mulVec ) ( a • x + b • y ) ≤ 16 / 9 from by rw [ ← eq_sub_iff_add_eq' ] at hab; subst hab; exact h_convex.trans ( by nlinarith [ hx.out, hy.out ] ) ;
            exact h_convex;
          · refine' measurableSet_le _ _;
            · fun_prop;
            · exact measurable_const;
        obtain ⟨ x, hx₁, hx₂, hx₃ ⟩ := h_minkowski; choose k hk using hx₃; use fun i => k i; aesop;
        · exact hx₂ ( by ext i; fin_cases i <;> assumption );
        · simp_all ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct ];
          convert hx₁ using 1 ; norm_num [ Matrix.vecMul ] ; ring;
      -- Since $Q(u)\in\Z$ and $16/9<2$, it follows that $Q(u)=1$.
      have h_Q_one : (Matrix.vecMul u B) ⬝ᵥ u ≤ 1 := by
        norm_num [ Matrix.vecMul, dotProduct ] at *;
        exact Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; linarith );
      have h_Q_pos : 0 < (Matrix.vecMul u B) ⬝ᵥ u := by
        have := h_pos.2;
        specialize this ( fun i => u i : Fin 2 → ℝ ) ; simp_all +decide [ Matrix.mulVec, dotProduct ];
        simp_all +decide [ funext_iff, Matrix.vecMul ];
        norm_cast at this; linarith;
      exact ⟨ u, hu.1, by linarith ⟩

#check IsCoprime.exists_SL2_col

/-
Every positive-definite integral binary quadratic form with determinant 1 is properly equivalent to the identity matrix (sum of squares).
-/
lemma unimodular_binary (B : Matrix (Fin 2) (Fin 2) ℤ) (h_pos : (B.map (Int.castRingHom ℝ)).PosDef) (h_det : B.det = 1) :
    ∃ A : Matrix.SpecialLinearGroup (Fin 2) ℤ, A.1.transpose * B * A.1 = 1 := by
      -- By Lemma `unit2`, there exists $u \in \mathbb{Z}^2$ such that $u^T B u = 1$.
      obtain ⟨u, hu_ne_zero, hu_eq⟩ : ∃ u : Fin 2 → ℤ, u ≠ 0 ∧ (Matrix.vecMul u B) ⬝ᵥ u = 1 := by
        exact?;
      -- Since $u$ is primitive, by `IsCoprime.exists_SL2_col`, there exists $A_1 \in \SL_2(\mathbb{Z})$ such that $A_1 e_1 = u$.
      obtain ⟨A1, hA1⟩ : ∃ A1 : Matrix.SpecialLinearGroup (Fin 2) ℤ, A1.1.mulVec (Pi.basisFun ℤ (Fin 2) 0) = u := by
        have h_coprime : IsCoprime (u 0) (u 1) := by
          norm_num [ Matrix.vecMul, Matrix.det_fin_two ] at hu_eq;
          exact ⟨ B 0 0 * u 0 + B 0 1 * u 1, B 1 0 * u 0 + B 1 1 * u 1, by linarith ⟩;
        have := IsCoprime.exists_SL2_col h_coprime 0;
        obtain ⟨ g, hg₀, hg₁ ⟩ := this; use g; ext i; fin_cases i <;> simp +decide [ *, Matrix.mulVec ] ;
      -- Let $B' = A_1^T B A_1$. Then $B'_{11} = e_1^T A_1^T B A_1 e_1 = u^T B u = 1$.
      set B' : Matrix (Fin 2) (Fin 2) ℤ := A1.1.transpose * B * A1.1
      have hB'_11 : B' 0 0 = 1 := by
        aesop;
        simp_all +decide [ Matrix.mul_apply, Matrix.vecMul ];
      -- Let $S = \begin{pmatrix} 1 & -s \\ 0 & 1 \end{pmatrix} \in \SL_2(\mathbb{Z})$.
      obtain ⟨s, hs⟩ : ∃ s : ℤ, B' 0 1 = s ∧ B' 1 0 = s ∧ B' 1 1 = 1 + s^2 := by
        have hB'_symm : B' 0 1 = B' 1 0 := by
          have hB'_symm : B'.transpose = B' := by
            have hB'_symm : B.transpose = B := by
              have := h_pos.1; aesop;
              ext i j; have := congr_fun ( congr_fun this i ) j; aesop;
            aesop;
            rw [ Matrix.mul_assoc ];
          exact congr_fun ( congr_fun hB'_symm 1 ) 0;
        have hB'_det : B'.det = 1 := by
          aesop;
        simp_all +decide [ Matrix.det_fin_two ];
        linarith;
      -- Let $S = \begin{pmatrix} 1 & -s \\ 0 & 1 \end{pmatrix} \in \SL_2(\mathbb{Z})$. Then $S^T B' S = \begin{pmatrix} 1 & 0 \\ 0 & t-s^2 \end{pmatrix}$.
      set S : Matrix (Fin 2) (Fin 2) ℤ := !![1, -s; 0, 1]
      have hS : S.transpose * B' * S = 1 := by
        ext i j ; fin_cases i <;> fin_cases j <;> norm_num [ Matrix.mul_apply, hs ];
        · aesop;
        · aesop;
        · aesop;
        · aesop ; ring;
      -- The required matrix is $A = A_1 S$.
      use ⟨A1.1 * S, by
        aesop⟩
      generalize_proofs at *;
      simp +zetaDelta at *;
      simpa only [ Matrix.mul_assoc ] using hS

/-
Every positive-definite integral ternary quadratic form $F$ with determinant $1$ is properly equivalent to $X^2+Y^2+Z^2$.
-/
theorem unimodular_ternary (F : IntegralTernaryQuadraticForm) (h_pos : F.PositiveDefinite) (h_det : F.det = 1) :
    F.ProperlyEquivalent IntegralTernaryQuadraticForm.sum_squares := by
      -- By Lemma `unit3` choose $v\in\Z^3$ with $F(v)=1$. Then $v$ is primitive.
      obtain ⟨v, hv⟩ : ∃ v : Fin 3 → ℤ, v ≠ 0 ∧ F.eval v = 1 := unit3 F h_pos h_det;
      -- By Lemma `primitive_to_e1` choose $A_0\in \SL_3(\Z)$ with $A_0e_1=v$ and set $M_0 = A_0^T M A_0$.
      obtain ⟨A0, hA0⟩ : ∃ A0 : Matrix.SpecialLinearGroup (Fin 3) ℤ, Matrix.mulVec A0.1 (Pi.basisFun ℤ (Fin 3) 0) = v := by
        -- By Lemma `primitive_to_e1`, since $v$ is primitive, there exists $A_0 \in \SL_3(\Z)$ such that $A_0 e_1 = v$.
        apply primitive_to_e1;
        -- Since $v$ is non-zero and $F(v) = 1$, the greatest common divisor of the components of $v$ must be 1.
        have h_gcd : ∀ d : ℤ, (∀ i, d ∣ v i) → d ∣ 1 := by
          intro d hd
          have h_div : d^2 ∣ F.eval v := by
            unfold IntegralTernaryQuadraticForm.eval at *; aesop;
            unfold Matrix.vecMul at right; simp_all +decide [ Fin.sum_univ_three, dotProduct ] ;
            obtain ⟨ k, hk ⟩ := hd 0; obtain ⟨ l, hl ⟩ := hd 1; obtain ⟨ m, hm ⟩ := hd 2; subst_vars; ring_nf at *; aesop;
            exact ⟨ k * l * F.toMatrix 1 0 + k * l * F.toMatrix 0 1 + k * m * F.toMatrix 2 0 + k * m * F.toMatrix 0 2 + k ^ 2 * F.toMatrix 0 0 + l * m * F.toMatrix 2 1 + l * m * F.toMatrix 1 2 + l ^ 2 * F.toMatrix 1 1 + m ^ 2 * F.toMatrix 2 2, by linarith ⟩;
          aesop;
          exact dvd_of_mul_left_dvd h_div;
        specialize h_gcd ( Finset.gcd Finset.univ v ) ; aesop;
        have := h_gcd ( fun i => Finset.gcd_dvd ( Finset.mem_univ i ) ) ; ( have := Int.isUnit_iff.mp ( isUnit_of_dvd_one this ) ; aesop; );
        simp_all +decide [ Fin.univ_succ ];
      -- Let $M_0 = A_0^T M A_0$. Then $(M_0)_{11}=e_1^T M_0 e_1 = v^T M v = F(v)=1$. Write $M_0=\begin{pmatrix}1 & r^T\\ r & C\end{pmatrix}$ with $r\in\Z^2$, $C\in M_2(\Z)$ symmetric.
      obtain ⟨r, C, hM0⟩ : ∃ r : Fin 2 → ℤ, ∃ C : Matrix (Fin 2) (Fin 2) ℤ, C.IsSymm ∧ (A0.1.transpose * F.toMatrix * A0.1) = Matrix.of ![![1, r 0, r 1], ![r 0, C 0 0, C 0 1], ![r 1, C 1 0, C 1 1]] := by
        -- Since $F$ is positive-definite and has determinant 1, and $A0$ is in $SL3(Z)$, the matrix $M0$ should have $(M0)_{11} = 1$.
        have hM0_11 : (A0.1.transpose * F.toMatrix * A0.1) 0 0 = 1 := by
          have hM0_11 : (Matrix.mulVec (Matrix.transpose (A0.1)) (F.toMatrix.mulVec (A0.1.mulVec (Pi.basisFun ℤ (Fin 3) 0)))) 0 = 1 := by
            unfold IntegralTernaryQuadraticForm.eval at hv; aesop;
          convert hM0_11 using 1;
          simp +decide [ Matrix.mul_assoc, Matrix.mulVec ];
          simp +decide [ Matrix.mul_apply, dotProduct ];
          simp +decide [ Matrix.mulVec, dotProduct ];
        -- Since $F$ is symmetric, $F.toMatrix$ is symmetric. Therefore, $(A0.1.transpose * F.toMatrix * A0.1)$ is also symmetric.
        have hM0_symm : (A0.1.transpose * F.toMatrix * A0.1).IsSymm := by
          simp_all ( config := { decide := Bool.true } ) [ Matrix.IsSymm, Matrix.transpose_mul ];
          simp ( config := { decide := Bool.true } ) [ Matrix.mul_assoc, show F.toMatrix.transpose = F.toMatrix from by ext i j; fin_cases i <;> fin_cases j <;> rfl ];
        use ![ (A0.1.transpose * F.toMatrix * A0.1) 0 1, (A0.1.transpose * F.toMatrix * A0.1) 0 2 ], ![![ (A0.1.transpose * F.toMatrix * A0.1) 1 1, (A0.1.transpose * F.toMatrix * A0.1) 1 2 ], ![ (A0.1.transpose * F.toMatrix * A0.1) 2 1, (A0.1.transpose * F.toMatrix * A0.1) 2 2 ]];
        simp_all +decide [ ← Matrix.ext_iff, Fin.forall_fin_succ ];
        have := congr_fun ( congr_fun hM0_symm 1 ) 2; ( have := congr_fun ( congr_fun hM0_symm 2 ) 1; ( have := congr_fun ( congr_fun hM0_symm 2 ) 0; ( have := congr_fun ( congr_fun hM0_symm 0 ) 2; ( have := congr_fun ( congr_fun hM0_symm 0 ) 1; ( have := congr_fun ( congr_fun hM0_symm 1 ) 0; ( norm_num at * ; aesop; ) ) ) ) ) );
        ext i j; fin_cases i <;> fin_cases j <;> norm_num;
      -- Let $S_1\in\SL_3(\Z)$ be the shear from Lemma `shear_lemma`. Then $M_1 := S_1^T M_0 S_1 = \mathrm{diag}(1,\,B)$, $B:=C-r r^T\in M_2(\Z)$ symmetric.
      obtain ⟨S1, hS1⟩ : ∃ S1 : Matrix.SpecialLinearGroup (Fin 3) ℤ, S1.1.transpose * (A0.1.transpose * F.toMatrix * A0.1) * S1.1 = Matrix.of ![![1, 0, 0], ![0, C 0 0 - r 0 ^ 2, C 0 1 - r 0 * r 1], ![0, C 1 0 - r 0 * r 1, C 1 1 - r 1 ^ 2]] := by
        -- Let $S_1$ be the shear matrix from Lemma `shear_lemma`.
        use ⟨Matrix.of ![![1, -r 0, -r 1], ![0, 1, 0], ![0, 0, 1]], by
          simp ( config := { decide := Bool.true } ) [ Matrix.det_fin_three ]⟩
        generalize_proofs at *;
        ext i j ; fin_cases i <;> fin_cases j <;> simp ( config := { decide := Bool.true } ) [ *, Matrix.mul_apply, Fin.sum_univ_succ ] <;> ring;
      -- Since $\det(M_1)=\det(M_0)=\det(M)=1$, we have $\det(B)=1$, and $B$ is positive definite.
      have hB_det : (C 0 0 - r 0 ^ 2) * (C 1 1 - r 1 ^ 2) - (C 0 1 - r 0 * r 1) ^ 2 = 1 := by
        have h_det_M1 : Matrix.det (S1.1.transpose * (A0.1.transpose * F.toMatrix * A0.1) * S1.1) = 1 := by
          have h_det_M1 : Matrix.det (A0.1.transpose * F.toMatrix * A0.1) = 1 := by
            simp_all +decide [ Matrix.det_mul ];
            rw [ ← hM0.2, Matrix.det_mul, Matrix.det_mul, Matrix.det_transpose ] ; aesop;
          have := S1.2; aesop;
          rw [ ← hS1, Matrix.det_mul, Matrix.det_mul, Matrix.det_transpose ] ; aesop;
        simp_all +decide [ Matrix.det_fin_three ];
        have := congr_fun ( congr_fun hM0.1 0 ) 1; aesop;
        linarith
      have hB_pos : (Matrix.map (Matrix.of ![![C 0 0 - r 0 ^ 2, C 0 1 - r 0 * r 1], ![C 1 0 - r 0 * r 1, C 1 1 - r 1 ^ 2]]) (Int.castRingHom ℝ)).PosDef := by
        have hB_pos : (Matrix.map (S1.1.transpose * (A0.1.transpose * F.toMatrix * A0.1) * S1.1) (Int.castRingHom ℝ)).PosDef := by
          have hB_pos : (Matrix.map (A0.1.transpose * F.toMatrix * A0.1) (Int.castRingHom ℝ)).PosDef := by
            have hB_pos : (Matrix.map (F.toMatrix) (Int.castRingHom ℝ)).PosDef := by
              exact h_pos;
            have hB_pos : ∀ (M : Matrix (Fin 3) (Fin 3) ℝ), M.PosDef → ∀ (A : Matrix (Fin 3) (Fin 3) ℝ), IsUnit A.det → (A.transpose * M * A).PosDef := by
              intros M hM A hA;
              constructor;
              · simp_all +decide [ Matrix.IsHermitian, Matrix.mul_assoc ];
                have := hM.1; simp_all +decide [ Matrix.IsHermitian, Matrix.transpose_mul ] ;
              · intro x hx_ne_zero
                have h_pos : 0 < star (A.mulVec x) ⬝ᵥ M.mulVec (A.mulVec x) := by
                  apply hM.2;
                  exact fun h => hx_ne_zero <| Matrix.eq_zero_of_mulVec_eq_zero ( show A.det ≠ 0 from hA.ne_zero ) h;
                convert h_pos using 1;
                simp +decide [ Matrix.mul_assoc, Matrix.dotProduct_mulVec, Matrix.vecMul_mulVec ];
            convert hB_pos _ ‹_› _ _ using 1;
            rotate_left;
            exact Matrix.map ( A0.1 ) ( Int.castRingHom ℝ );
            · simp +decide [ Matrix.det_apply' ];
              norm_cast;
              exact ne_of_eq_of_ne ( show ( ∑ x : Equiv.Perm ( Fin 3 ), ( Equiv.Perm.sign x : ℤ ) * ∏ i : Fin 3, A0 ( x i ) i ) = 1 from by simpa [ Matrix.det_apply' ] using A0.2 ) ( by norm_num );
            · ext i j ; simp +decide [ Matrix.mul_apply, Matrix.transpose_apply ];
          have hB_pos : ∀ (M : Matrix (Fin 3) (Fin 3) ℝ), M.PosDef → ∀ (S : Matrix (Fin 3) (Fin 3) ℝ), S.det = 1 → (S.transpose * M * S).PosDef := by
            intros M hM S hS_det
            have h_pos_def : ∀ x : Fin 3 → ℝ, x ≠ 0 → 0 < dotProduct x (Matrix.mulVec (S.transpose * M * S) x) := by
              intros x hx_nonzero
              have h_pos_def : 0 < dotProduct (Matrix.mulVec S x) (Matrix.mulVec M (Matrix.mulVec S x)) := by
                have := hM.2 ( S.mulVec x );
                exact this ( fun h => hx_nonzero <| by simpa [ hS_det ] using congr_arg ( fun y => S⁻¹.mulVec y ) h );
              convert h_pos_def using 1;
              simp +decide [ Matrix.mul_assoc, Matrix.dotProduct_mulVec, Matrix.vecMul_mulVec ];
            constructor;
            · simp_all +decide [ Matrix.IsHermitian, Matrix.mul_assoc ];
              have := hM.1; simp_all +decide [ Matrix.IsHermitian, Matrix.transpose_mul ] ;
            · exact?;
          convert hB_pos _ ‹_› _ _ using 1;
          rotate_left;
          exact Matrix.map ( S1 : Matrix ( Fin 3 ) ( Fin 3 ) ℤ ) ( Int.castRingHom ℝ );
          · convert S1.2 using 1;
            norm_num [ Matrix.det_apply' ];
            norm_cast;
          · ext i j ; simp +decide [ Matrix.mul_apply, Matrix.transpose_apply ];
        simp_all +decide [ Matrix.PosDef ];
        constructor;
        · ext i j; fin_cases i <;> fin_cases j <;> norm_num;
          · exact hM0.1.apply _ _ ▸ rfl;
          · exact hM0.1.apply _ _ ▸ rfl;
        · intro x hx; specialize hB_pos; have := hB_pos.2 ( Matrix.vecCons 0 x ) ; simp_all +decide [ Matrix.mulVec ] ;
          simp_all +decide [ Matrix.vecHead, Matrix.vecTail, Matrix.mulVec ];
      -- By Lemma `unimodular_binary` applied to $B$, there exists $A_2 \in \SL_2(\Z)$ such that $A_2^T B A_2 = I_2$.
      obtain ⟨A2, hA2⟩ : ∃ A2 : Matrix.SpecialLinearGroup (Fin 2) ℤ, A2.1.transpose * Matrix.of ![![C 0 0 - r 0 ^ 2, C 0 1 - r 0 * r 1], ![C 1 0 - r 0 * r 1, C 1 1 - r 1 ^ 2]] * A2.1 = 1 := by
        convert unimodular_binary _ hB_pos _;
        simp_all ( config := { decide := Bool.true } ) [ Matrix.det_fin_two ];
        convert hB_det using 1 ; rw [ show C 1 0 = C 0 1 by simpa [ eq_comm ] using congr_fun ( congr_fun hM0.1 1 ) 0 ] ; ring;
      -- Embed $A_2$ into $\SL_3(\Z)$ as $\widetilde{A}_2 = \mathrm{diag}(1, A_2)$.
      obtain ⟨A2_tilde, hA2_tilde⟩ : ∃ A2_tilde : Matrix.SpecialLinearGroup (Fin 3) ℤ, A2_tilde.1.transpose * (Matrix.of ![![1, 0, 0], ![0, C 0 0 - r 0 ^ 2, C 0 1 - r 0 * r 1], ![0, C 1 0 - r 0 * r 1, C 1 1 - r 1 ^ 2]]) * A2_tilde.1 = 1 := by
        use ⟨Matrix.of ![![1, 0, 0], ![0, A2.1 0 0, A2.1 0 1], ![0, A2.1 1 0, A2.1 1 1]], by
          simp +decide [ Matrix.det_fin_three ];
          convert A2.2 using 1;
          rw [ Matrix.det_fin_two ]⟩
        generalize_proofs at *;
        ext i j ; fin_cases i <;> fin_cases j <;> simp ( config := { decide := Bool.true } ) [ *, Matrix.mul_apply, Fin.sum_univ_succ ];
        · have := congr_fun ( congr_fun hA2 0 ) 0; norm_num [ Matrix.mul_apply, Fin.sum_univ_succ ] at this; linarith;
        · have := congr_fun ( congr_fun hA2 0 ) 1; norm_num [ Matrix.mul_apply, Fin.sum_univ_succ ] at this; linarith!;
        · have := congr_fun ( congr_fun hA2 1 ) 0; norm_num [ Matrix.mul_apply, Fin.sum_univ_succ ] at this; linarith!;
        · have := congr_fun ( congr_fun hA2 1 ) 1; norm_num [ Matrix.mul_apply, Fin.sum_univ_succ ] at this; linarith!;
      -- The total transformation is $A = A_0 S_1 \widetilde{A}_2 \in \SL_3(\Z)$.
      use A0 * S1 * A2_tilde;
      simp_all +decide [ ← mul_assoc, Matrix.SpecialLinearGroup.ext_iff ];
      simp_all +decide [ mul_assoc, Matrix.mul_assoc ]

/-
If a positive definite integral ternary quadratic form matrix $M$ has determinant 1 and $M_{11}=1$, then it is equivalent to the identity matrix.
-/
lemma reduce_unit_pivot (M : Matrix (Fin 3) (Fin 3) ℤ) (h_pos : (M.map (Int.castRingHom ℝ)).PosDef) (h_det : M.det = 1) (h_11 : M 0 0 = 1) :
    ∃ A : Matrix.SpecialLinearGroup (Fin 3) ℤ, A.1.transpose * M * A.1 = 1 := by
      -- By `unimodular_ternary`, there exists an $A \in \SL_3(\Z)$ such that $A^T M A = I_3$.
      obtain ⟨A, hA⟩ : ∃ A : Matrix.SpecialLinearGroup (Fin 3) ℤ, A.1.transpose * M * A.1 = 1 := by
        have h_unimodular : ∀ (F : IntegralTernaryQuadraticForm), F.PositiveDefinite → F.det = 1 → F.ProperlyEquivalent IntegralTernaryQuadraticForm.sum_squares := by
          bound;
          apply_rules [ unimodular_ternary ]
        obtain ⟨A, hA⟩ : ∃ A : Matrix.SpecialLinearGroup (Fin 3) ℤ, A.1.transpose * M * A.1 = 1 := by
          have h_form : ∃ F : IntegralTernaryQuadraticForm, F.toMatrix = M := by
            use ⟨M 0 0, M 1 1, M 2 2, M 0 1, M 0 2, M 1 2⟩;
            -- Since $M$ is symmetric, the matrix constructed from its entries is also symmetric.
            have h_symm : M 0 1 = M 1 0 ∧ M 0 2 = M 2 0 ∧ M 1 2 = M 2 1 := by
              have := h_pos.1;
              simp_all ( config := { decide := Bool.true } ) [ Matrix.IsHermitian, ← Matrix.ext_iff ];
            ext i j; fin_cases i <;> fin_cases j <;> tauto;
          obtain ⟨ F, rfl ⟩ := h_form;
          have := h_unimodular F h_pos h_det; rcases this with ⟨ A, hA ⟩ ; use A; aesop;
          exact hA.symm.trans ( by ext i j; fin_cases i <;> fin_cases j <;> rfl );
        use A;
      use A

/-
Legendre's Three-Square Theorem: A natural number n is a sum of three
squares if and only if n is not of the form 4^a(8b+7).
-/
theorem LegendreThreeSquareTheorem (n : ℕ) : IsSumOfThreeSquares n ↔
    ∀ a b : ℕ, n ≠ 4^a * (8 * b + 7) := by
  apply ConditionalLegendreThreeSquareTheorem;
  exact fun F hF hF' => unimodular_ternary F hF hF'
